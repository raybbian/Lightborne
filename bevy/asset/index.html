<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="In the context of game development, an “asset” is a piece of content that is loaded from disk and displayed in the game. Typically, these are authored by artists and designers (in contrast to code), are relatively large in size, and include everything from textures and models to sounds and music to levels and scripts."><title>bevy::asset - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bevy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../../crates.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../bevy/index.html">bevy</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#loading-assets" title="Loading assets">Loading assets</a></li><li><a href="#modifying-entities-that-use-assets" title="Modifying entities that use assets">Modifying entities that use assets</a></li><li><a href="#hot-reloading-assets" title="Hot reloading assets">Hot reloading assets</a></li><li><a href="#procedural-asset-creation" title="Procedural asset creation">Procedural asset creation</a><ul><li><a href="#handles-and-reference-counting" title="Handles and reference counting">Handles and reference counting</a></li></ul></li><li><a href="#asset-dependencies" title="Asset dependencies">Asset dependencies</a></li><li><a href="#custom-asset-types" title="Custom asset types">Custom asset types</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">bevy</a></span><h1>Crate <span>asset</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bevy_asset/lib.rs.html#1-1784">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>In the context of game development, an “asset” is a piece of content that is loaded from disk and displayed in the game.
Typically, these are authored by artists and designers (in contrast to code),
are relatively large in size, and include everything from textures and models to sounds and music to levels and scripts.</p>
<p>This presents two main challenges:</p>
<ul>
<li>Assets take up a lot of memory; simply storing a copy for each instance of an asset in the game would be prohibitively expensive.</li>
<li>Loading assets from disk is slow, and can cause long load times and delays.</li>
</ul>
<p>These problems play into each other, for if assets are expensive to store in memory,
then larger game worlds will need to load them from disk as needed, ideally without a loading screen.</p>
<p>As is common in Rust, non-blocking asset loading is done using <code>async</code>, with background tasks used to load assets while the game is running.
Bevy coordinates these tasks using the <a href="../prelude/struct.AssetServer.html" title="struct bevy::prelude::AssetServer"><code>AssetServer</code></a> resource, storing each loaded asset in a strongly-typed <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets&lt;T&gt;</code></a> collection (also a resource).
<a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a>s serve as an id-based reference to entries in the <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collection, allowing them to be cheaply shared between systems,
and providing a way to initialize objects (generally entities) before the required assets are loaded.
In short: <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a>s are not the assets themselves, they just tell how to look them up!</p>
<h3 id="loading-assets"><a class="doc-anchor" href="#loading-assets">§</a>Loading assets</h3>
<p>The <a href="../prelude/struct.AssetServer.html" title="struct bevy::prelude::AssetServer"><code>AssetServer</code></a> is the main entry point for loading assets.
Typically, you’ll use the <a href="../prelude/struct.AssetServer.html#method.load" title="method bevy::prelude::AssetServer::load"><code>AssetServer::load</code></a> method to load an asset from disk, which returns a <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a>.
Note that this method does not attempt to reload the asset if it has already been loaded: as long as at least one handle has not been dropped,
calling <a href="../prelude/struct.AssetServer.html#method.load" title="method bevy::prelude::AssetServer::load"><code>AssetServer::load</code></a> on the same path will return the same handle.
The handle that’s returned can be used to instantiate various <a href="../prelude/trait.Component.html" title="trait bevy::prelude::Component"><code>Component</code></a>s that require asset data to function,
which will then be spawned into the world as part of an entity.</p>
<p>To avoid assets “popping” into existence, you may want to check that all of the required assets are loaded before transitioning to a new scene.
This can be done by checking the <a href="enum.LoadState.html" title="enum bevy::asset::LoadState"><code>LoadState</code></a> of the asset handle using <a href="../prelude/struct.AssetServer.html#method.is_loaded_with_dependencies" title="method bevy::prelude::AssetServer::is_loaded_with_dependencies"><code>AssetServer::is_loaded_with_dependencies</code></a>,
which will be <code>true</code> when the asset is ready to use.</p>
<p>Keep track of what you’re waiting on by using a <a href="../utils/type.HashSet.html" title="type bevy::utils::HashSet"><code>HashSet</code></a> of asset handles or similar data structure,
which iterate over and poll in your update loop, and transition to the new scene once all assets are loaded.
Bevy’s built-in states system can be very helpful for this!</p>
<h2 id="modifying-entities-that-use-assets"><a class="doc-anchor" href="#modifying-entities-that-use-assets">§</a>Modifying entities that use assets</h2>
<p>If we later want to change the asset data a given component uses (such as changing an entity’s material), we have three options:</p>
<ol>
<li>Change the handle stored on the responsible component to the handle of a different asset</li>
<li>Despawn the entity and spawn a new one with the new asset data.</li>
<li>Use the <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collection to directly modify the current handle’s asset data</li>
</ol>
<p>The first option is the most common: just query for the component that holds the handle, and mutate it, pointing to the new asset.
Check how the handle was passed in to the entity when it was spawned: if a mesh-related component required a handle to a mesh asset,
you’ll need to find that component via a query and change the handle to the new mesh asset.
This is so commonly done that you should think about strategies for how to store and swap handles in your game.</p>
<p>The second option is the simplest, but can be slow if done frequently,
and can lead to frustrating bugs as references to the old entity (such as what is targeting it) and other data on the entity are lost.
Generally, this isn’t a great strategy.</p>
<p>The third option has different semantics: rather than modifying the asset data for a single entity, it modifies the asset data for <em>all</em> entities using this handle.
While this might be what you want, it generally isn’t!</p>
<h2 id="hot-reloading-assets"><a class="doc-anchor" href="#hot-reloading-assets">§</a>Hot reloading assets</h2>
<p>Bevy supports asset hot reloading, allowing you to change assets on disk and see the changes reflected in your game without restarting.
When enabled, any changes to the underlying asset file will be detected by the <a href="../prelude/struct.AssetServer.html" title="struct bevy::prelude::AssetServer"><code>AssetServer</code></a>, which will then reload the asset,
mutating the asset data in the <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collection and thus updating all entities that use the asset.
While it has limited uses in published games, it is very useful when developing, as it allows you to iterate quickly.</p>
<p>To enable asset hot reloading on desktop platforms, enable <code>bevy</code>’s <code>file_watcher</code> cargo feature.
To toggle it at runtime, you can use the <code>watch_for_changes_override</code> field in the <a href="../prelude/struct.AssetPlugin.html" title="struct bevy::prelude::AssetPlugin"><code>AssetPlugin</code></a> to enable or disable hot reloading.</p>
<h2 id="procedural-asset-creation"><a class="doc-anchor" href="#procedural-asset-creation">§</a>Procedural asset creation</h2>
<p>Not all assets are loaded from disk: some are generated at runtime, such as procedural materials, sounds or even levels.
After creating an item of a type that implements <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a>, you can add it to the <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collection using <a href="../prelude/struct.Assets.html#method.add" title="method bevy::prelude::Assets::add"><code>Assets::add</code></a>.
Once in the asset collection, this data can be operated on like any other asset.</p>
<p>Note that, unlike assets loaded from a file path, no general mechanism currently exists to deduplicate procedural assets:
calling <a href="../prelude/struct.Assets.html#method.add" title="method bevy::prelude::Assets::add"><code>Assets::add</code></a> for every entity that needs the asset will create a new copy of the asset for each entity,
quickly consuming memory.</p>
<h3 id="handles-and-reference-counting"><a class="doc-anchor" href="#handles-and-reference-counting">§</a>Handles and reference counting</h3>
<p><a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a> (or their untyped counterpart <a href="../prelude/enum.UntypedHandle.html" title="enum bevy::prelude::UntypedHandle"><code>UntypedHandle</code></a>) are used to reference assets in the <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collection,
and are the primary way to interact with assets in Bevy.
As a user, you’ll be working with handles a lot!</p>
<p>The most important thing to know about handles is that they are reference counted: when you clone a handle, you’re incrementing a reference count.
When the object holding the handle is dropped (generally because an entity was despawned), the reference count is decremented.
When the reference count hits zero, the asset it references is removed from the <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collection.</p>
<p>This reference counting is a simple, largely automatic way to avoid holding onto memory for game objects that are no longer in use.
However, it can lead to surprising behavior if you’re not careful!</p>
<p>There are two categories of problems to watch out for:</p>
<ul>
<li>never dropping a handle, causing the asset to never be removed from memory</li>
<li>dropping a handle too early, causing the asset to be removed from memory while it’s still in use</li>
</ul>
<p>The first problem is less critical for beginners, as for tiny games, you can often get away with simply storing all of the assets in memory at once,
and loading them all at the start of the game.
As your game grows, you’ll need to be more careful about when you load and unload assets,
segmenting them by level or area, and loading them on-demand.
This problem generally arises when handles are stored in a persistent “collection” or “manifest” of possible objects (generally in a resource),
which is convenient for easy access and zero-latency spawning, but can result in high but stable memory usage.</p>
<p>The second problem is more concerning, and looks like your models or textures suddenly disappearing from the game.
Debugging reveals that the <em>entities</em> are still there, but nothing is rendering!
This is because the assets were removed from memory while they were still in use.
You were probably too aggressive with the use of weak handles (which don’t increment the reference count of the asset): think through the lifecycle of your assets carefully!
As soon as an asset is loaded, you must ensure that at least one strong handle is held to it until all matching entities are out of sight of the player.</p>
<h2 id="asset-dependencies"><a class="doc-anchor" href="#asset-dependencies">§</a>Asset dependencies</h2>
<p>Some assets depend on other assets to be loaded before they can be loaded themselves.
For example, a 3D model might require both textures and meshes to be loaded,
or a 2D level might require a tileset to be loaded.</p>
<p>The assets that are required to load another asset are called “dependencies”.
An asset is only considered fully loaded when it and all of its dependencies are loaded.
Asset dependencies can be declared when implementing the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> trait by implementing the <a href="trait.VisitAssetDependencies.html" title="trait bevy::asset::VisitAssetDependencies"><code>VisitAssetDependencies</code></a> trait,
and the <code>#[dependency]</code> attribute can be used to automatically derive this implementation.</p>
<h2 id="custom-asset-types"><a class="doc-anchor" href="#custom-asset-types">§</a>Custom asset types</h2>
<p>While Bevy comes with implementations for a large number of common game-oriented asset types (often behind off-by-default feature flags!),
implementing a custom asset type can be useful when dealing with unusual, game-specific, or proprietary formats.</p>
<p>Defining a new asset type is as simple as implementing the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> trait.
This requires <a href="../prelude/trait.TypePath.html" title="trait bevy::prelude::TypePath"><code>TypePath</code></a> for metadata about the asset type,
and <a href="trait.VisitAssetDependencies.html" title="trait bevy::asset::VisitAssetDependencies"><code>VisitAssetDependencies</code></a> to track asset dependencies.
In simple cases, you can derive <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> and <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a> and be done with it: the required supertraits will be implemented for you.</p>
<p>With a new asset type in place, we now need to figure out how to load it.
While <a href="io/trait.AssetReader.html" title="trait bevy::asset::io::AssetReader"><code>AssetReader</code></a> describes strategies to read asset bytes from various sources,
<a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a> is the trait that actually turns those into your desired in-memory format.
Generally, (only) <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a> needs to be implemented for custom assets, as the <a href="io/trait.AssetReader.html" title="trait bevy::asset::io::AssetReader"><code>AssetReader</code></a> implementations are provided by Bevy.</p>
<p>However, <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a> shouldn’t be implemented for your asset type directly: instead, this is implemented for a “loader” type
that can store settings and any additional data required to load your asset, while your asset type is used as the <a href="trait.AssetLoader.html#associatedtype.Asset" title="associated type bevy::asset::AssetLoader::Asset"><code>AssetLoader::Asset</code></a> associated type.
As the trait documentation explains, this allows various <a href="trait.AssetLoader.html#associatedtype.Settings" title="associated type bevy::asset::AssetLoader::Settings"><code>AssetLoader::Settings</code></a> to be used to configure the loader.</p>
<p>After the loader is implemented, it needs to be registered with the <a href="../prelude/struct.AssetServer.html" title="struct bevy::prelude::AssetServer"><code>AssetServer</code></a> using <a href="../prelude/trait.AssetApp.html#tymethod.register_asset_loader" title="method bevy::prelude::AssetApp::register_asset_loader"><code>App::register_asset_loader</code></a>.
Once your asset type is loaded, you can use it in your game like any other asset type!</p>
<p>If you want to save your assets back to disk, you should implement <a href="saver/trait.AssetSaver.html" title="trait bevy::asset::saver::AssetSaver"><code>AssetSaver</code></a> as well.
This trait mirrors <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a> in structure, and works in tandem with <a href="io/trait.AssetWriter.html" title="trait bevy::asset::io::AssetWriter"><code>AssetWriter</code></a>, which mirrors <a href="io/trait.AssetReader.html" title="trait bevy::asset::io::AssetReader"><code>AssetReader</code></a>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="io/index.html" title="mod bevy::asset::io">io</a></div></li><li><div class="item-name"><a class="mod" href="meta/index.html" title="mod bevy::asset::meta">meta</a></div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod bevy::asset::prelude">prelude</a></div><div class="desc docblock-short">The asset prelude.</div></li><li><div class="item-name"><a class="mod" href="processor/index.html" title="mod bevy::asset::processor">processor</a></div><div class="desc docblock-short">Asset processing in Bevy is a framework for automatically transforming artist-authored assets into the format that best suits the needs of your particular game.</div></li><li><div class="item-name"><a class="mod" href="ron/index.html" title="mod bevy::asset::ron">ron</a></div><div class="desc docblock-short">Rusty Object Notation</div></li><li><div class="item-name"><a class="mod" href="saver/index.html" title="mod bevy::asset::saver">saver</a></div></li><li><div class="item-name"><a class="mod" href="transformer/index.html" title="mod bevy::asset::transformer">transformer</a></div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.embedded_asset.html" title="macro bevy::asset::embedded_asset">embedded_<wbr>asset</a></div><div class="desc docblock-short">Creates a new <code>embedded</code> asset by embedding the bytes of the given path into the current binary
and registering those bytes with the <code>embedded</code> <a href="io/struct.AssetSource.html" title="struct bevy::asset::io::AssetSource"><code>AssetSource</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.embedded_path.html" title="macro bevy::asset::embedded_path">embedded_<wbr>path</a></div><div class="desc docblock-short">Returns the <a href="https://doc.rust-lang.org/1.85.0/std/path/struct.Path.html" title="struct std::path::Path"><code>Path</code></a> for a given <code>embedded</code> asset.
This is used internally by <a href="macro.embedded_asset.html" title="macro bevy::asset::embedded_asset"><code>embedded_asset</code></a> and can be used to get a <a href="https://doc.rust-lang.org/1.85.0/std/path/struct.Path.html" title="struct std::path::Path"><code>Path</code></a>
that matches the <a href="struct.AssetPath.html" title="struct bevy::asset::AssetPath"><code>AssetPath</code></a> used by that asset.</div></li><li><div class="item-name"><a class="macro" href="macro.load_internal_asset.html" title="macro bevy::asset::load_internal_asset">load_<wbr>internal_<wbr>asset</a></div><div class="desc docblock-short">Loads an “internal” asset by embedding the string stored in the given <code>path_str</code> and associates it with the given handle.</div></li><li><div class="item-name"><a class="macro" href="macro.load_internal_binary_asset.html" title="macro bevy::asset::load_internal_binary_asset">load_<wbr>internal_<wbr>binary_<wbr>asset</a></div><div class="desc docblock-short">Loads an “internal” binary asset by embedding the bytes stored in the given <code>path_str</code> and associates it with the given handle.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AddAsyncError.html" title="struct bevy::asset::AddAsyncError">AddAsync<wbr>Error</a></div></li><li><div class="item-name"><a class="struct" href="struct.AssetEvents.html" title="struct bevy::asset::AssetEvents">Asset<wbr>Events</a></div><div class="desc docblock-short">A system set where events accumulated in <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> are applied to the <a href="../prelude/enum.AssetEvent.html" title="enum bevy::prelude::AssetEvent"><code>AssetEvent</code></a> <a href="../prelude/struct.Events.html" title="struct bevy::prelude::Events"><code>Events</code></a> resource.</div></li><li><div class="item-name"><a class="struct" href="struct.AssetHandleProvider.html" title="struct bevy::asset::AssetHandleProvider">Asset<wbr>Handle<wbr>Provider</a></div><div class="desc docblock-short">Provides <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a> and <a href="../prelude/enum.UntypedHandle.html" title="enum bevy::prelude::UntypedHandle"><code>UntypedHandle</code></a> <em>for a specific asset type</em>.
This should <em>only</em> be used for one specific asset type.</div></li><li><div class="item-name"><a class="struct" href="struct.AssetIndex.html" title="struct bevy::asset::AssetIndex">Asset<wbr>Index</a></div><div class="desc docblock-short">A generational runtime-only identifier for a specific <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> stored in <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a>. This is optimized for efficient runtime
usage and is not suitable for identifying assets across app runs.</div></li><li><div class="item-name"><a class="struct" href="struct.AssetLoadFailedEvent.html" title="struct bevy::asset::AssetLoadFailedEvent">Asset<wbr>Load<wbr>Failed<wbr>Event</a></div><div class="desc docblock-short">An event emitted when a specific <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> fails to load.</div></li><li><div class="item-name"><a class="struct" href="struct.AssetLoaderError.html" title="struct bevy::asset::AssetLoaderError">Asset<wbr>Loader<wbr>Error</a></div></li><li><div class="item-name"><a class="struct" href="struct.AssetPath.html" title="struct bevy::asset::AssetPath">Asset<wbr>Path</a></div><div class="desc docblock-short">Represents a path to an asset in a “virtual filesystem”.</div></li><li><div class="item-name"><a class="struct" href="struct.AssetPlugin.html" title="struct bevy::asset::AssetPlugin">Asset<wbr>Plugin</a></div><div class="desc docblock-short">Provides “asset” loading and processing functionality. An <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> is a “runtime value” that is loaded from an <a href="io/struct.AssetSource.html" title="struct bevy::asset::io::AssetSource"><code>AssetSource</code></a>,
which can be something like a filesystem, a network, etc.</div></li><li><div class="item-name"><a class="struct" href="struct.AssetServer.html" title="struct bevy::asset::AssetServer">Asset<wbr>Server</a></div><div class="desc docblock-short">Loads and tracks the state of <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> values from a configured <a href="io/trait.AssetReader.html" title="trait bevy::asset::io::AssetReader"><code>AssetReader</code></a>. This can be used to kick off new asset loads and
retrieve their current load states.</div></li><li><div class="item-name"><a class="struct" href="struct.Assets.html" title="struct bevy::asset::Assets">Assets</a></div><div class="desc docblock-short">Stores <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> values identified by their <a href="../prelude/enum.AssetId.html" title="enum bevy::prelude::AssetId"><code>AssetId</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.AssetsMutIterator.html" title="struct bevy::asset::AssetsMutIterator">Assets<wbr>MutIterator</a></div><div class="desc docblock-short">A mutable iterator over <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Deferred.html" title="struct bevy::asset::Deferred">Deferred</a></div><div class="desc docblock-short"><a href="struct.NestedLoader.html" title="struct bevy::asset::NestedLoader"><code>NestedLoader</code></a> will create and return asset handles immediately, but only
actually load the asset later.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicTyped.html" title="struct bevy::asset::DynamicTyped">Dynamic<wbr>Typed</a></div><div class="desc docblock-short"><a href="struct.NestedLoader.html" title="struct bevy::asset::NestedLoader"><code>NestedLoader</code></a> has been configured with info on what type of asset to load
at runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.ErasedLoadedAsset.html" title="struct bevy::asset::ErasedLoadedAsset">Erased<wbr>Loaded<wbr>Asset</a></div><div class="desc docblock-short">A “type erased / boxed” counterpart to <a href="struct.LoadedAsset.html" title="struct bevy::asset::LoadedAsset"><code>LoadedAsset</code></a>. This is used in places where the loaded type is not statically known.</div></li><li><div class="item-name"><a class="struct" href="struct.Immediate.html" title="struct bevy::asset::Immediate">Immediate</a></div><div class="desc docblock-short"><a href="struct.NestedLoader.html" title="struct bevy::asset::NestedLoader"><code>NestedLoader</code></a> will immediately load an asset when requested.</div></li><li><div class="item-name"><a class="struct" href="struct.InvalidGenerationError.html" title="struct bevy::asset::InvalidGenerationError">Invalid<wbr>Generation<wbr>Error</a></div></li><li><div class="item-name"><a class="struct" href="struct.LoadContext.html" title="struct bevy::asset::LoadContext">Load<wbr>Context</a></div><div class="desc docblock-short">A context that provides access to assets in <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a>s, tracks dependencies, and collects asset load state.</div></li><li><div class="item-name"><a class="struct" href="struct.LoadDirectError.html" title="struct bevy::asset::LoadDirectError">Load<wbr>Direct<wbr>Error</a></div><div class="desc docblock-short">An error that occurs when attempting to call <a href="struct.NestedLoader.html#method.load" title="method bevy::asset::NestedLoader::load"><code>NestedLoader::load</code></a> which
is configured to work <a href="struct.Immediate.html" title="struct bevy::asset::Immediate">immediately</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.LoadedAsset.html" title="struct bevy::asset::LoadedAsset">Loaded<wbr>Asset</a></div><div class="desc docblock-short">The successful result of an <a href="trait.AssetLoader.html#tymethod.load" title="method bevy::asset::AssetLoader::load"><code>AssetLoader::load</code></a> call. This contains the loaded “root” asset and any other “labeled” assets produced
by the loader. It also holds the input <a href="meta/struct.AssetMeta.html" title="struct bevy::asset::meta::AssetMeta"><code>AssetMeta</code></a> (if it exists) and tracks dependencies:</div></li><li><div class="item-name"><a class="struct" href="struct.LoadedFolder.html" title="struct bevy::asset::LoadedFolder">Loaded<wbr>Folder</a></div><div class="desc docblock-short">A “loaded folder” containing handles for all assets stored in a given <a href="struct.AssetPath.html" title="struct bevy::asset::AssetPath"><code>AssetPath</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.LoadedUntypedAsset.html" title="struct bevy::asset::LoadedUntypedAsset">Loaded<wbr>Untyped<wbr>Asset</a></div><div class="desc docblock-short">A “loaded asset” containing the untyped handle for an asset stored in a given <a href="struct.AssetPath.html" title="struct bevy::asset::AssetPath"><code>AssetPath</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.MissingAssetLoaderForExtensionError.html" title="struct bevy::asset::MissingAssetLoaderForExtensionError">Missing<wbr>Asset<wbr>Loader<wbr>ForExtension<wbr>Error</a></div><div class="desc docblock-short">An error that occurs when an <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a> is not registered for a given extension.</div></li><li><div class="item-name"><a class="struct" href="struct.MissingAssetLoaderForTypeIdError.html" title="struct bevy::asset::MissingAssetLoaderForTypeIdError">Missing<wbr>Asset<wbr>Loader<wbr>ForType<wbr>IdError</a></div><div class="desc docblock-short">An error that occurs when an <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a> is not registered for a given <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> <a href="https://doc.rust-lang.org/1.85.0/core/any/struct.TypeId.html" title="struct core::any::TypeId"><code>TypeId</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.MissingAssetLoaderForTypeNameError.html" title="struct bevy::asset::MissingAssetLoaderForTypeNameError">Missing<wbr>Asset<wbr>Loader<wbr>ForType<wbr>Name<wbr>Error</a></div><div class="desc docblock-short">An error that occurs when an <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a> is not registered for a given <a href="https://doc.rust-lang.org/1.85.0/core/any/fn.type_name.html" title="fn core::any::type_name"><code>std::any::type_name</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.NestedLoader.html" title="struct bevy::asset::NestedLoader">Nested<wbr>Loader</a></div><div class="desc docblock-short">A builder for loading nested assets inside a <a href="struct.LoadContext.html" title="struct bevy::asset::LoadContext"><code>LoadContext</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ReflectAsset.html" title="struct bevy::asset::ReflectAsset">Reflect<wbr>Asset</a></div><div class="desc docblock-short">Type data for the <a href="../reflect/struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry"><code>TypeRegistry</code></a> used to operate on reflected <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a>s.</div></li><li><div class="item-name"><a class="struct" href="struct.ReflectHandle.html" title="struct bevy::asset::ReflectHandle">Reflect<wbr>Handle</a></div><div class="desc docblock-short">Reflect type data struct relating a <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle&lt;T&gt;</code></a> back to the <code>T</code> asset type.</div></li><li><div class="item-name"><a class="struct" href="struct.RenderAssetUsages.html" title="struct bevy::asset::RenderAssetUsages">Render<wbr>Asset<wbr>Usages</a></div><div class="desc docblock-short">Defines where the asset will be used.</div></li><li><div class="item-name"><a class="struct" href="struct.StaticTyped.html" title="struct bevy::asset::StaticTyped">Static<wbr>Typed</a></div><div class="desc docblock-short"><a href="struct.NestedLoader.html" title="struct bevy::asset::NestedLoader"><code>NestedLoader</code></a> will be provided the type of asset as a type parameter on
<a href="struct.NestedLoader.html#method.load" title="method bevy::asset::NestedLoader::load"><code>load</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.StrongHandle.html" title="struct bevy::asset::StrongHandle">Strong<wbr>Handle</a></div><div class="desc docblock-short">The internal “strong” <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> handle storage for <a href="../prelude/enum.Handle.html#variant.Strong" title="variant bevy::prelude::Handle::Strong"><code>Handle::Strong</code></a> and <a href="../prelude/enum.UntypedHandle.html#variant.Strong" title="variant bevy::prelude::UntypedHandle::Strong"><code>UntypedHandle::Strong</code></a>. When this is dropped,
the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> will be freed. It also stores some asset metadata for easy access from handles.</div></li><li><div class="item-name"><a class="struct" href="struct.TrackAssets.html" title="struct bevy::asset::TrackAssets">Track<wbr>Assets</a></div><div class="desc docblock-short">A system set that holds all “track asset” operations.</div></li><li><div class="item-name"><a class="struct" href="struct.UnknownTyped.html" title="struct bevy::asset::UnknownTyped">Unknown<wbr>Typed</a></div><div class="desc docblock-short"><a href="struct.NestedLoader.html" title="struct bevy::asset::NestedLoader"><code>NestedLoader</code></a> does not know what type of asset it will be loading.</div></li><li><div class="item-name"><a class="struct" href="struct.UntypedAssetLoadFailedEvent.html" title="struct bevy::asset::UntypedAssetLoadFailedEvent">Untyped<wbr>Asset<wbr>Load<wbr>Failed<wbr>Event</a></div><div class="desc docblock-short">An untyped version of <a href="struct.AssetLoadFailedEvent.html" title="struct bevy::asset::AssetLoadFailedEvent"><code>AssetLoadFailedEvent</code></a>.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AssetEvent.html" title="enum bevy::asset::AssetEvent">Asset<wbr>Event</a></div><div class="desc docblock-short">Events that occur for a specific loaded <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a>, such as “value changed” events and “dependency” events.</div></li><li><div class="item-name"><a class="enum" href="enum.AssetId.html" title="enum bevy::asset::AssetId">AssetId</a></div><div class="desc docblock-short">A unique runtime-only identifier for an <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a>. This is cheap to <a href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a>/<a href="https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html" title="trait core::clone::Clone"><code>Clone</code></a> and is not directly tied to the
lifetime of the Asset. This means it <em>can</em> point to an <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> that no longer exists.</div></li><li><div class="item-name"><a class="enum" href="enum.AssetLoadError.html" title="enum bevy::asset::AssetLoadError">Asset<wbr>Load<wbr>Error</a></div><div class="desc docblock-short">An error that occurs during an <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> load.</div></li><li><div class="item-name"><a class="enum" href="enum.AssetMetaCheck.html" title="enum bevy::asset::AssetMetaCheck">Asset<wbr>Meta<wbr>Check</a></div><div class="desc docblock-short">Configures how / if meta files will be checked. If an asset’s meta file is not checked, the default meta for the asset
will be used.</div></li><li><div class="item-name"><a class="enum" href="enum.AssetMode.html" title="enum bevy::asset::AssetMode">Asset<wbr>Mode</a></div><div class="desc docblock-short">Controls whether or not assets are pre-processed before being loaded.</div></li><li><div class="item-name"><a class="enum" href="enum.AssetServerMode.html" title="enum bevy::asset::AssetServerMode">Asset<wbr>Server<wbr>Mode</a></div><div class="desc docblock-short">The “asset mode” the server is currently in.</div></li><li><div class="item-name"><a class="enum" href="enum.DependencyLoadState.html" title="enum bevy::asset::DependencyLoadState">Dependency<wbr>Load<wbr>State</a></div><div class="desc docblock-short">The load state of an asset’s dependencies.</div></li><li><div class="item-name"><a class="enum" href="enum.DeserializeMetaError.html" title="enum bevy::asset::DeserializeMetaError">Deserialize<wbr>Meta<wbr>Error</a></div><div class="desc docblock-short">An error that occurs while deserializing <a href="meta/struct.AssetMeta.html" title="struct bevy::asset::meta::AssetMeta"><code>AssetMeta</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.Handle.html" title="enum bevy::asset::Handle">Handle</a></div><div class="desc docblock-short">A strong or weak handle to a specific <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a>. If a <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a> is <a href="../prelude/enum.Handle.html#variant.Strong" title="variant bevy::prelude::Handle::Strong"><code>Handle::Strong</code></a>, the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> will be kept
alive until the <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a> is dropped. If a <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a> is <a href="../prelude/enum.Handle.html#variant.Weak" title="variant bevy::prelude::Handle::Weak"><code>Handle::Weak</code></a>, it does not necessarily reference a live <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a>,
nor will it keep assets alive.</div></li><li><div class="item-name"><a class="enum" href="enum.LoadState.html" title="enum bevy::asset::LoadState">Load<wbr>State</a></div><div class="desc docblock-short">The load state of an asset.</div></li><li><div class="item-name"><a class="enum" href="enum.ParseAssetPathError.html" title="enum bevy::asset::ParseAssetPathError">Parse<wbr>Asset<wbr>Path<wbr>Error</a></div><div class="desc docblock-short">An error that occurs when parsing a string type to create an <a href="struct.AssetPath.html" title="struct bevy::asset::AssetPath"><code>AssetPath</code></a> fails, such as during <a href="struct.AssetPath.html#method.parse" title="associated function bevy::asset::AssetPath::parse"><code>AssetPath::parse</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.ReadAssetBytesError.html" title="enum bevy::asset::ReadAssetBytesError">Read<wbr>Asset<wbr>Bytes<wbr>Error</a></div><div class="desc docblock-short">An error produced when calling <a href="struct.LoadContext.html#method.read_asset_bytes" title="method bevy::asset::LoadContext::read_asset_bytes"><code>LoadContext::read_asset_bytes</code></a></div></li><li><div class="item-name"><a class="enum" href="enum.RecursiveDependencyLoadState.html" title="enum bevy::asset::RecursiveDependencyLoadState">Recursive<wbr>Dependency<wbr>Load<wbr>State</a></div><div class="desc docblock-short">The recursive load state of an asset’s dependencies.</div></li><li><div class="item-name"><a class="enum" href="enum.UntypedAssetConversionError.html" title="enum bevy::asset::UntypedAssetConversionError">Untyped<wbr>Asset<wbr>Conversion<wbr>Error</a></div><div class="desc docblock-short">Errors preventing the conversion of to/from an <a href="../prelude/enum.UntypedHandle.html" title="enum bevy::prelude::UntypedHandle"><code>UntypedHandle</code></a> and a <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.UntypedAssetId.html" title="enum bevy::asset::UntypedAssetId">Untyped<wbr>Asset<wbr>Id</a></div><div class="desc docblock-short">An “untyped” / “generic-less” <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> identifier that behaves much like <a href="../prelude/enum.AssetId.html" title="enum bevy::prelude::AssetId"><code>AssetId</code></a>, but stores the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> type
information at runtime instead of compile-time. This increases the size of the type, but it enables storing asset ids
across asset types together and enables comparisons between them.</div></li><li><div class="item-name"><a class="enum" href="enum.UntypedAssetIdConversionError.html" title="enum bevy::asset::UntypedAssetIdConversionError">Untyped<wbr>Asset<wbr>IdConversion<wbr>Error</a></div><div class="desc docblock-short">Errors preventing the conversion of to/from an <a href="enum.UntypedAssetId.html" title="enum bevy::asset::UntypedAssetId"><code>UntypedAssetId</code></a> and an <a href="../prelude/enum.AssetId.html" title="enum bevy::prelude::AssetId"><code>AssetId</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.UntypedHandle.html" title="enum bevy::asset::UntypedHandle">Untyped<wbr>Handle</a></div><div class="desc docblock-short">An untyped variant of <a href="../prelude/enum.Handle.html" title="enum bevy::prelude::Handle"><code>Handle</code></a>, which internally stores the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> type information at runtime
as a <a href="https://doc.rust-lang.org/1.85.0/core/any/struct.TypeId.html" title="struct core::any::TypeId"><code>TypeId</code></a> instead of encoding it in the compile-time type. This allows handles across <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> types
to be stored together and compared.</div></li><li><div class="item-name"><a class="enum" href="enum.WaitForAssetError.html" title="enum bevy::asset::WaitForAssetError">Wait<wbr>ForAsset<wbr>Error</a></div><div class="desc docblock-short">An error when attempting to wait asynchronously for an <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> to load.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Asset.html" title="trait bevy::asset::Asset">Asset</a></div><div class="desc docblock-short">Declares that this type is an asset,
which can be loaded and managed by the <a href="../prelude/struct.AssetServer.html" title="struct bevy::prelude::AssetServer"><code>AssetServer</code></a> and stored in <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collections.</div></li><li><div class="item-name"><a class="trait" href="trait.AssetApp.html" title="trait bevy::asset::AssetApp">Asset<wbr>App</a></div><div class="desc docblock-short">Adds asset-related builder methods to <a href="../prelude/struct.App.html" title="struct bevy::prelude::App"><code>App</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.AssetContainer.html" title="trait bevy::asset::AssetContainer">Asset<wbr>Container</a></div><div class="desc docblock-short">A type erased container for an <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> value that is capable of inserting the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> into a <a href="../prelude/struct.World.html" title="struct bevy::prelude::World"><code>World</code></a>’s <a href="../prelude/struct.Assets.html" title="struct bevy::prelude::Assets"><code>Assets</code></a> collection.</div></li><li><div class="item-name"><a class="trait" href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader">Asset<wbr>Loader</a></div><div class="desc docblock-short">Loads an <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a> from a given byte <a href="io/trait.Reader.html" title="trait bevy::asset::io::Reader"><code>Reader</code></a>. This can accept <a href="trait.AssetLoader.html#associatedtype.Settings" title="associated type bevy::asset::AssetLoader::Settings"><code>AssetLoader::Settings</code></a>, which configure how the <a href="../prelude/trait.Asset.html" title="trait bevy::prelude::Asset"><code>Asset</code></a>
should be loaded.</div></li><li><div class="item-name"><a class="trait" href="trait.AsyncReadExt.html" title="trait bevy::asset::AsyncReadExt">Async<wbr>Read<wbr>Ext</a></div><div class="desc docblock-short">Extension trait for <a href="../tasks/futures_lite/trait.AsyncRead.html" title="trait bevy::tasks::futures_lite::AsyncRead"><code>AsyncRead</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.AsyncWriteExt.html" title="trait bevy::asset::AsyncWriteExt">Async<wbr>Write<wbr>Ext</a></div><div class="desc docblock-short">Extension trait for <a href="../tasks/futures_lite/trait.AsyncWrite.html" title="trait bevy::tasks::futures_lite::AsyncWrite"><code>AsyncWrite</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.DirectAssetAccessExt.html" title="trait bevy::asset::DirectAssetAccessExt">Direct<wbr>Asset<wbr>Access<wbr>Ext</a></div></li><li><div class="item-name"><a class="trait" href="trait.ErasedAssetLoader.html" title="trait bevy::asset::ErasedAssetLoader">Erased<wbr>Asset<wbr>Loader</a></div><div class="desc docblock-short">Provides type-erased access to an <a href="trait.AssetLoader.html" title="trait bevy::asset::AssetLoader"><code>AssetLoader</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.VisitAssetDependencies.html" title="trait bevy::asset::VisitAssetDependencies">Visit<wbr>Asset<wbr>Dependencies</a></div><div class="desc docblock-short">This trait defines how to visit the dependencies of an asset.
For example, a 3D model might require both textures and meshes to be loaded.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.handle_internal_asset_events.html" title="fn bevy::asset::handle_internal_asset_events">handle_<wbr>internal_<wbr>asset_<wbr>events</a></div><div class="desc docblock-short">A system that manages internal <a href="../prelude/struct.AssetServer.html" title="struct bevy::prelude::AssetServer"><code>AssetServer</code></a> events, such as finalizing asset loads.</div></li></ul><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.Asset.html" title="derive bevy::asset::Asset">Asset</a></div></li></ul></section></div></main></body></html>