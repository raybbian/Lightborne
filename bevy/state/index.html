<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="In Bevy, states are app-wide interdependent, finite state machines that are generally used to model the large scale structure of your program: whether a game is paused, if the player is in combat, if assets are loaded and so on."><title>bevy::state - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bevy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../../crates.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../bevy/index.html">bevy</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">bevy</a></span><h1>Crate <span>state</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bevy_state/lib.rs.html#1-79">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>In Bevy, states are app-wide interdependent, finite state machines that are generally used to model the large scale structure of your program: whether a game is paused, if the player is in combat, if assets are loaded and so on.</p>
<p>This module provides 3 distinct types of state, all of which implement the <a href="../prelude/trait.States.html" title="trait bevy::prelude::States"><code>States</code></a> trait:</p>
<ul>
<li>Standard <a href="../prelude/trait.States.html" title="trait bevy::prelude::States"><code>States</code></a> can only be changed by manually setting the <a href="../prelude/enum.NextState.html" title="enum bevy::prelude::NextState"><code>NextState&lt;S&gt;</code></a> resource.
These states are the baseline on which the other state types are built, and can be used on
their own for many simple patterns. See the <a href="https://github.com/bevyengine/bevy/blob/latest/examples/state/state.rs">state example</a>
for a simple use case.</li>
<li><a href="../prelude/trait.SubStates.html" title="trait bevy::prelude::SubStates"><code>SubStates</code></a> are children of other states - they can be changed manually using <a href="../prelude/enum.NextState.html" title="enum bevy::prelude::NextState"><code>NextState&lt;S&gt;</code></a>,
but are removed from the <a href="../prelude/struct.World.html" title="struct bevy::prelude::World"><code>World</code></a> if the source states aren’t in the right state. See the <a href="https://github.com/bevyengine/bevy/blob/latest/examples/state/sub_states.rs">sub_states example</a>
for a simple use case based on the derive macro, or read the trait docs for more complex scenarios.</li>
<li><a href="../prelude/trait.ComputedStates.html" title="trait bevy::prelude::ComputedStates"><code>ComputedStates</code></a> are fully derived from other states - they provide a <a href="../prelude/trait.ComputedStates.html#tymethod.compute" title="associated function bevy::prelude::ComputedStates::compute"><code>compute</code></a> method
that takes in the source states and returns their derived value. They are particularly useful for situations
where a simplified view of the source states is necessary - such as having an <code>InAMenu</code> computed state, derived
from a source state that defines multiple distinct menus. See the <a href="https://github.com/bevyengine/bevy/blob/latest/examples/state/computed_states.rs">computed state example</a>
to see usage samples for these states.</li>
</ul>
<p>Most of the utilities around state involve running systems during transitions between states, or
determining whether to run certain systems, though they can be used more directly as well. This
makes it easier to transition between menus, add loading screens, pause games, and the more.</p>
<p>Specifically, Bevy provides the following utilities:</p>
<ul>
<li>3 Transition Schedules - <a href="../prelude/struct.OnEnter.html" title="struct bevy::prelude::OnEnter"><code>OnEnter&lt;S&gt;</code></a>, <a href="../prelude/struct.OnExit.html" title="struct bevy::prelude::OnExit"><code>OnExit&lt;S&gt;</code></a> and <a href="../prelude/struct.OnTransition.html" title="struct bevy::prelude::OnTransition"><code>OnTransition&lt;S&gt;</code></a> - which are used
to trigger systems specifically during matching transitions.</li>
<li>A <a href="../prelude/struct.StateTransitionEvent.html" title="struct bevy::prelude::StateTransitionEvent"><code>StateTransitionEvent&lt;S&gt;</code></a> that gets fired when a given state changes.</li>
<li>The <a href="../prelude/fn.in_state.html" title="fn bevy::prelude::in_state"><code>in_state&lt;S&gt;</code></a> and <a href="../prelude/fn.state_changed.html" title="fn bevy::prelude::state_changed"><code>state_changed&lt;S&gt;</code></a> run conditions - which are used
to determine whether a system should run based on the current state.</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="app/index.html" title="mod bevy::state::app">app</a></div><div class="desc docblock-short">Provides <a href="../prelude/struct.App.html" title="struct bevy::prelude::App"><code>App</code></a> and <a href="../prelude/struct.SubApp.html" title="struct bevy::prelude::SubApp"><code>SubApp</code></a> with state installation methods</div></li><li><div class="item-name"><a class="mod" href="commands/index.html" title="mod bevy::state::commands">commands</a></div><div class="desc docblock-short">Provides extension methods for <a href="../prelude/struct.Commands.html" title="struct bevy::prelude::Commands"><code>Commands</code></a>.</div></li><li><div class="item-name"><a class="mod" href="condition/index.html" title="mod bevy::state::condition">condition</a></div><div class="desc docblock-short">Provides definitions for the runtime conditions that interact with the state system</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod bevy::state::prelude">prelude</a></div><div class="desc docblock-short">The state prelude.</div></li><li><div class="item-name"><a class="mod" href="reflect/index.html" title="mod bevy::state::reflect">reflect</a></div><div class="desc docblock-short">Provides definitions for the basic traits required by the state system</div></li><li><div class="item-name"><a class="mod" href="state/index.html" title="mod bevy::state::state">state</a></div><div class="desc docblock-short">Provides definitions for the basic traits required by the state system</div></li><li><div class="item-name"><a class="mod" href="state_scoped/index.html" title="mod bevy::state::state_scoped">state_<wbr>scoped</a></div><div class="desc docblock-short">Provides <a href="../prelude/struct.StateScoped.html" title="struct bevy::prelude::StateScoped"><code>StateScoped</code></a> and
<a href="state_scoped/fn.clear_state_scoped_entities.html" title="fn bevy::state::state_scoped::clear_state_scoped_entities"><code>clear_state_scoped_entities</code></a> for managing lifetime of entities.</div></li><li><div class="item-name"><a class="mod" href="state_scoped_events/index.html" title="mod bevy::state::state_scoped_events">state_<wbr>scoped_<wbr>events</a></div><div class="desc docblock-short">Provides <a href="../prelude/struct.App.html" title="struct bevy::prelude::App"><code>App</code></a> and <a href="../prelude/struct.SubApp.html" title="struct bevy::prelude::SubApp"><code>SubApp</code></a> with methods for registering
state-scoped events.</div></li></ul></section></div></main></body></html>