<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `Curve` trait, providing a domain-agnostic description of curves."><title>bevy::math::curve - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bevy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../../bevy/index.html">bevy</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module curve</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#overview" title="Overview">Overview</a></li><li><a href="#analogy-with-iterator" title="Analogy with `Iterator`">Analogy with <code>Iterator</code></a></li><li><a href="#defining-curves" title="Defining curves">Defining curves</a></li><li><a href="#transforming-curves" title="Transforming curves">Transforming curves</a></li><li><a href="#combining-curves" title="Combining curves">Combining curves</a></li><li><a href="#resampling-and-rasterization" title="Resampling and rasterization">Resampling and rasterization</a></li><li><a href="#ownership-and-borrowing" title="Ownership and borrowing">Ownership and borrowing</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In bevy::<wbr>math</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">bevy</a>::<wbr><a href="../index.html">math</a></span><h1>Module <span>curve</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/bevy_math/lib.rs.html#32">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <a href="../../prelude/trait.Curve.html" title="trait bevy::prelude::Curve"><code>Curve</code></a> trait, providing a domain-agnostic description of curves.</p>
<h3 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h3>
<p>At a high level, <a href="../../prelude/trait.Curve.html" title="trait bevy::prelude::Curve"><code>Curve</code></a> is a trait that abstracts away the implementation details of curves,
which comprise any kind of data parametrized by a single continuous variable. For example, that
variable could represent time, in which case a curve would represent a value that changes over
time, as in animation; on the other hand, it could represent something like displacement or
distance, as in graphs, gradients, and curves in space.</p>
<p>The trait itself has two fundamental components: a curve must have a <a href="../../prelude/trait.Curve.html#tymethod.domain" title="method bevy::prelude::Curve::domain">domain</a>, which is a nonempty
range of <code>f32</code> values, and it must be able to be <a href="../../prelude/trait.Curve.html#method.sample" title="method bevy::prelude::Curve::sample">sampled</a> on every one of those values, producing
output of some fixed type.</p>
<p>A primary goal of the trait is to allow interfaces to simply accept <code>impl Curve&lt;T&gt;</code> as input
rather than requiring for input curves to be defined in data in any particular way. This is
supported by a number of interface methods which allow <a href="../../prelude/trait.Curve.html#method.reparametrize" title="method bevy::prelude::Curve::reparametrize">changing parametrizations</a>, <a href="../../prelude/trait.Curve.html#method.map" title="method bevy::prelude::Curve::map">mapping output</a>,
and <a href="../../prelude/trait.Curve.html#method.resample" title="method bevy::prelude::Curve::resample">rasterization</a>.</p>
<h3 id="analogy-with-iterator"><a class="doc-anchor" href="#analogy-with-iterator">§</a>Analogy with <code>Iterator</code></h3>
<p>The <code>Curve</code> API behaves, in many ways, like a continuous counterpart to <a href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>. The analogy
looks something like this with some of the common methods:</p>
<div><table><thead><tr><th style="text-align: left">Iterators</th><th style="text-align: left">Curves</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>map</code></td><td style="text-align: left"><code>map</code></td></tr>
<tr><td style="text-align: left"><code>skip</code>/<code>step_by</code></td><td style="text-align: left"><code>reparametrize</code></td></tr>
<tr><td style="text-align: left"><code>enumerate</code></td><td style="text-align: left"><code>graph</code></td></tr>
<tr><td style="text-align: left"><code>chain</code></td><td style="text-align: left"><code>chain</code></td></tr>
<tr><td style="text-align: left"><code>zip</code></td><td style="text-align: left"><code>zip</code></td></tr>
<tr><td style="text-align: left"><code>rev</code></td><td style="text-align: left"><code>reverse</code></td></tr>
<tr><td style="text-align: left"><code>by_ref</code></td><td style="text-align: left"><code>by_ref</code></td></tr>
</tbody></table>
</div>
<p>Of course, there are very important differences, as well. For instance, the continuous nature of
curves means that many iterator methods make little sense in the context of curves, or at least
require numerical techniques. For example, the analogue of <code>sum</code> would be an integral, approximated
by something like Riemann summation.</p>
<p>Furthermore, the two also differ greatly in their orientation to borrowing and mutation:
iterators are mutated by being iterated, and by contrast, all curve methods are immutable. More
information on the implications of this can be found <a href="index.html#Ownership-and-borrowing" title="mod bevy::math::curve">below</a>.</p>
<h3 id="defining-curves"><a class="doc-anchor" href="#defining-curves">§</a>Defining curves</h3>
<p>Curves may be defined in a number of ways. The following are common:</p>
<ul>
<li>using <a href="../../prelude/struct.FunctionCurve.html" title="struct bevy::prelude::FunctionCurve">functions</a>;</li>
<li>using <a href="../../prelude/struct.SampleCurve.html" title="struct bevy::prelude::SampleCurve">sample interpolation</a>;</li>
<li>using <a href="../cubic_splines/index.html" title="mod bevy::math::cubic_splines">splines</a>;</li>
<li>using <a href="../../prelude/easing/index.html" title="mod bevy::prelude::easing">easings</a>.</li>
</ul>
<p>Among these, the first is the most versatile<sup id="fnref1"><a href="#fn1">1</a></sup>: the domain and the sampling output are just
specified directly in the construction. For this reason, function curves are a reliable go-to for
simple one-off constructions and procedural uses, where flexibility is desirable. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A sinusoid:
</span><span class="kw">let </span>sine_curve = FunctionCurve::new(Interval::EVERYWHERE, f32::sin);

<span class="comment">// A sawtooth wave:
</span><span class="kw">let </span>sawtooth_curve = FunctionCurve::new(Interval::EVERYWHERE, |t| t % <span class="number">1.0</span>);

<span class="comment">// A helix:
</span><span class="kw">let </span>helix_curve = FunctionCurve::new(Interval::EVERYWHERE, |theta| vec3(theta.sin(), theta, theta.cos()));</code></pre></div>
<p>Sample-interpolated curves commonly arises in both rasterization and in animation, and this library
has support for producing them in both fashions. See <a href="index.html#Resampling-and-rasterization" title="mod bevy::math::curve">below</a> for
more information about rasterization. Here is what an explicit sample-interpolated curve might look like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A list of angles that we want to traverse:
</span><span class="kw">let </span>angles = [
    <span class="number">0.0</span>,
    -FRAC_PI_2,
    <span class="number">0.0</span>,
    FRAC_PI_2,
    <span class="number">0.0
</span>];

<span class="comment">// Make each angle into a rotation by that angle:
</span><span class="kw">let </span>rotations = angles.map(|angle| Rot2::radians(angle));

<span class="comment">// Interpolate these rotations with a `Rot2`-valued curve:
</span><span class="kw">let </span>rotation_curve = SampleAutoCurve::new(interval(<span class="number">0.0</span>, <span class="number">4.0</span>).unwrap(), rotations).unwrap();</code></pre></div>
<p>For more information on <a href="../cubic_splines/index.html" title="mod bevy::math::cubic_splines">spline curves</a> and <a href="../../prelude/easing/index.html" title="mod bevy::prelude::easing">easing curves</a>, see their respective modules.</p>
<p>And, of course, you are also free to define curve types yourself, implementing the trait directly.
For custom sample-interpolated curves, the <a href="../../prelude/cores/index.html" title="mod bevy::prelude::cores"><code>cores</code></a> submodule provides machinery to avoid having to
reimplement interpolation logic yourself. In many other cases, implementing the trait directly is
often quite straightforward:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>ExponentialCurve {
    exponent: f32,
}

<span class="kw">impl </span>Curve&lt;f32&gt; <span class="kw">for </span>ExponentialCurve {
    <span class="kw">fn </span>domain(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Interval {
        Interval::EVERYWHERE
    }

    <span class="kw">fn </span>sample_unchecked(<span class="kw-2">&amp;</span><span class="self">self</span>, t: f32) -&gt; f32 {
        f32::exp(<span class="self">self</span>.exponent * t)
    }

    <span class="comment">// All other trait methods can be inferred from these.
</span>}</code></pre></div>
<h3 id="transforming-curves"><a class="doc-anchor" href="#transforming-curves">§</a>Transforming curves</h3>
<p>The API provides a few key ways of transforming one curve into another. These are often useful when
you would like to make use of an interface that requires a curve that bears some logical relationship
to one that you already have access to, but with different requirements or expectations. For example,
the output type of the curves may differ, or the domain may be expected to be different. The <code>map</code>
and <code>reparametrize</code> methods can help address this.</p>
<p>As a simple example of the kind of thing that arises in practice, let’s imagine that we have a
<code>Curve&lt;Vec2&gt;</code> that we want to use to describe the motion of some object over time, but the interface
for animation expects a <code>Curve&lt;Vec3&gt;</code>, since the object will move in three dimensions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Our original curve, which may look something like this:
</span><span class="kw">let </span>ellipse_curve = FunctionCurve::new(
    interval(<span class="number">0.0</span>, TAU).unwrap(),
    |t| vec2(t.cos(), t.sin() * <span class="number">2.0</span>)
);

<span class="comment">// Use `map` to situate this in 3D as a Curve&lt;Vec3&gt;; in this case, it will be in the xy-plane:
</span><span class="kw">let </span>ellipse_motion_curve = ellipse_curve.map(|pos| pos.extend(<span class="number">0.0</span>));</code></pre></div>
<p>We might imagine further still that the interface expects the curve to have domain <code>[0, 1]</code>. The
<code>reparametrize</code> methods can address this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Change the domain to `[0, 1]` instead of `[0, TAU]`:
</span><span class="kw">let </span>final_curve = ellipse_motion_curve.reparametrize_linear(Interval::UNIT).unwrap();</code></pre></div>
<p>Of course, there are many other ways of using these methods. In general, <code>map</code> is used for transforming
the output and using it to drive something else, while <code>reparametrize</code> preserves the curve’s shape but
changes the speed and direction in which it is traversed. For instance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A line segment curve connecting two points in the plane:
</span><span class="kw">let </span>start = vec2(-<span class="number">1.0</span>, <span class="number">1.0</span>);
<span class="kw">let </span>end = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>);
<span class="kw">let </span>segment = FunctionCurve::new(Interval::UNIT, |t| start.lerp(end, t));

<span class="comment">// Let's make a curve that goes back and forth along this line segment forever.
//
// Start by stretching the line segment in parameter space so that it travels along its length
// from `-1` to `1` instead of `0` to `1`:
</span><span class="kw">let </span>stretched_segment = segment.reparametrize_linear(interval(-<span class="number">1.0</span>, <span class="number">1.0</span>).unwrap()).unwrap();

<span class="comment">// Now, the *output* of `f32::sin` in `[-1, 1]` corresponds to the *input* interval of
// `stretched_segment`; the sinusoid output is mapped to the input parameter and controls how
// far along the segment we are:
</span><span class="kw">let </span>back_and_forth_curve = stretched_segment.reparametrize(Interval::EVERYWHERE, f32::sin);</code></pre></div>
<h3 id="combining-curves"><a class="doc-anchor" href="#combining-curves">§</a>Combining curves</h3>
<p>Curves become more expressive when used together. For example, maybe you want to combine two
curves end-to-end:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A line segment connecting `(-1, 0)` to `(0, 0)`:
</span><span class="kw">let </span>line_curve = FunctionCurve::new(
    Interval::UNIT,
    |t| vec2(-<span class="number">1.0</span>, <span class="number">0.0</span>).lerp(vec2(<span class="number">0.0</span>, <span class="number">0.0</span>), t)
);

<span class="comment">// A half-circle curve starting at `(0, 0)`:
</span><span class="kw">let </span>half_circle_curve = FunctionCurve::new(
    interval(<span class="number">0.0</span>, PI).unwrap(),
    |t| vec2(t.cos() * -<span class="number">1.0 </span>+ <span class="number">1.0</span>, t.sin())
);

<span class="comment">// A curve that traverses `line_curve` and then `half_circle_curve` over the interval
// from `0` to `PI + 1`:
</span><span class="kw">let </span>combined_curve = line_curve.chain(half_circle_curve).unwrap();</code></pre></div>
<p>Or, instead, maybe you want to combine two curves the <em>other</em> way, producing a single curve
that combines their output in a tuple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Some entity's position in 2D:
</span><span class="kw">let </span>position_curve = FunctionCurve::new(Interval::UNIT, |t| vec2(t.cos(), t.sin()));

<span class="comment">// The same entity's orientation, described as a rotation. (In this case it will be spinning.)
</span><span class="kw">let </span>orientation_curve = FunctionCurve::new(Interval::UNIT, |t| Rot2::radians(<span class="number">5.0 </span>* t));

<span class="comment">// Both in one curve with `(Vec2, Rot2)` output:
</span><span class="kw">let </span>position_and_orientation = position_curve.zip(orientation_curve).unwrap();</code></pre></div>
<p>See the documentation on <a href="../../prelude/trait.Curve.html#method.chain" title="method bevy::prelude::Curve::chain"><code>chain</code></a> and <a href="../../prelude/trait.Curve.html#method.zip" title="method bevy::prelude::Curve::zip"><code>zip</code></a> for more details on how these methods work.</p>
<h3 id="resampling-and-rasterization"><a class="doc-anchor" href="#resampling-and-rasterization">§</a><a name="Resampling-and-rasterization"></a>Resampling and rasterization</h3>
<p>Sometimes, for reasons of portability, performance, or otherwise, it can be useful to ensure that
curves of various provenance all actually share the same concrete type. This is the purpose of the
<a href="../../prelude/trait.Curve.html#method.resample" title="method bevy::prelude::Curve::resample"><code>resample</code></a> family of functions: they allow a curve to be replaced by an approximate version of
itself defined by interpolation over samples from the original curve.</p>
<p>In effect, this allows very different curves to be rasterized and treated uniformly. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A curve that is not easily transported because it relies on evaluating a function:
</span><span class="kw">let </span>interesting_curve = FunctionCurve::new(Interval::UNIT, |t| vec2(t * <span class="number">3.0</span>, t.exp()));

<span class="comment">// A rasterized form of the preceding curve which is just a `SampleAutoCurve`. Inside, this
// just stores an `Interval` along with a buffer of sample data, so it's easy to serialize
// and deserialize:
</span><span class="kw">let </span>resampled_curve = interesting_curve.resample_auto(<span class="number">100</span>).unwrap();

<span class="comment">// The rasterized form can be seamlessly used as a curve itself:
</span><span class="kw">let </span>some_value = resampled_curve.sample(<span class="number">0.5</span>).unwrap();</code></pre></div>
<h3 id="ownership-and-borrowing"><a class="doc-anchor" href="#ownership-and-borrowing">§</a><a name="Ownership-and-borrowing"></a>Ownership and borrowing</h3>
<p>It can be easy to get tripped up by how curves specifically interact with Rust’s ownership semantics.
First of all, it’s worth noting that the API never uses <code>&amp;mut self</code> — every method either takes
ownership of the original curve or uses a shared reference.</p>
<p>Because of the methods that take ownership, it is useful to be aware of the following:</p>
<ul>
<li>If <code>curve</code> is a curve, then <code>&amp;curve</code> is also a curve with the same output. For convenience,
<code>&amp;curve</code> can be written as <code>curve.by_ref()</code> for use in method chaining.</li>
<li>However, <code>&amp;curve</code> cannot outlive <code>curve</code>. In general, it is not <code>'static</code>.</li>
</ul>
<p>In other words, <code>&amp;curve</code> can be used to perform temporary operations without consuming <code>curve</code> (for
example, to effectively pass <code>curve</code> into an API which expects an <code>impl Curve&lt;T&gt;</code>), but it <em>cannot</em>
be used in situations where persistence is necessary (e.g. when the curve itself must be stored
for later use).</p>
<p>Here is a demonstration:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//`my_curve` is obtained somehow. It is a `Curve&lt;(f32, f32)&gt;`.
</span><span class="kw">let </span>my_curve = some_magic_constructor();

<span class="comment">// Now, we want to sample a mapped version of `my_curve`.

// let samples: Vec&lt;f32&gt; = my_curve.map(|(x, y)| y).samples(50).unwrap().collect();
// ^ This would work, but it would also invalidate `my_curve`, since `map` takes ownership.

// Instead, we pass a borrowed version of `my_curve` to `map`. It lives long enough that we
// can extract samples:
</span><span class="kw">let </span>samples: Vec&lt;f32&gt; = my_curve.by_ref().map(|(x, y)| y).samples(<span class="number">50</span>).unwrap().collect();

<span class="comment">// This way, we retain the ability to use `my_curve` later:
</span><span class="kw">let </span>new_curve = my_curve.map(|(x,y)| x + y);</code></pre></div>
<div class="footnotes"><hr><ol><li id="fn1"><p>In fact, universal as well, in some sense: if <code>curve</code> is any curve, then <code>FunctionCurve::new (curve.domain(), |t| curve.sample_unchecked(t))</code> is an equivalent function curve.&nbsp;<a href="#fnref1">↩</a></p></li></ol></div></div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ChainCurve.html" title="struct bevy::math::curve::ChainCurve">Chain<wbr>Curve</a></div><div class="desc docblock-short">The curve that results from chaining one curve with another. The second curve is
effectively reparametrized so that its start is at the end of the first.</div></li><li><div class="item-name"><a class="struct" href="struct.ConstantCurve.html" title="struct bevy::math::curve::ConstantCurve">Constant<wbr>Curve</a></div><div class="desc docblock-short">A curve with a constant value over its domain.</div></li><li><div class="item-name"><a class="struct" href="struct.ContinuationCurve.html" title="struct bevy::math::curve::ContinuationCurve">Continuation<wbr>Curve</a></div><div class="desc docblock-short">The curve that results from chaining two curves.</div></li><li><div class="item-name"><a class="struct" href="struct.CurveReparamCurve.html" title="struct bevy::math::curve::CurveReparamCurve">Curve<wbr>Reparam<wbr>Curve</a></div><div class="desc docblock-short">A curve that has been reparametrized by another curve, using that curve to transform the
sample times before sampling. Curves of this type are produced by <a href="../../prelude/trait.Curve.html#method.reparametrize_by_curve" title="method bevy::prelude::Curve::reparametrize_by_curve"><code>Curve::reparametrize_by_curve</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.EasingCurve.html" title="struct bevy::math::curve::EasingCurve">Easing<wbr>Curve</a></div><div class="desc docblock-short">A <a href="../../prelude/trait.Curve.html" title="trait bevy::prelude::Curve"><code>Curve</code></a> that is defined by</div></li><li><div class="item-name"><a class="struct" href="struct.ForeverCurve.html" title="struct bevy::math::curve::ForeverCurve">Forever<wbr>Curve</a></div><div class="desc docblock-short">The curve that results from repeating a curve forever.</div></li><li><div class="item-name"><a class="struct" href="struct.FunctionCurve.html" title="struct bevy::math::curve::FunctionCurve">Function<wbr>Curve</a></div><div class="desc docblock-short">A curve defined by a function together with a fixed domain.</div></li><li><div class="item-name"><a class="struct" href="struct.GraphCurve.html" title="struct bevy::math::curve::GraphCurve">Graph<wbr>Curve</a></div><div class="desc docblock-short">A curve that is the graph of another curve over its parameter space. Curves of this type are
produced by <a href="../../prelude/trait.Curve.html#method.graph" title="method bevy::prelude::Curve::graph"><code>Curve::graph</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Interval.html" title="struct bevy::math::curve::Interval">Interval</a></div><div class="desc docblock-short">A nonempty closed interval, possibly unbounded in either direction.</div></li><li><div class="item-name"><a class="struct" href="struct.LinearReparamCurve.html" title="struct bevy::math::curve::LinearReparamCurve">Linear<wbr>Reparam<wbr>Curve</a></div><div class="desc docblock-short">A curve that has had its domain changed by a linear reparametrization (stretching and scaling).
Curves of this type are produced by <a href="../../prelude/trait.Curve.html#method.reparametrize_linear" title="method bevy::prelude::Curve::reparametrize_linear"><code>Curve::reparametrize_linear</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.MapCurve.html" title="struct bevy::math::curve::MapCurve">MapCurve</a></div><div class="desc docblock-short">A curve whose samples are defined by mapping samples from another curve through a
given function. Curves of this type are produced by <a href="../../prelude/trait.Curve.html#method.map" title="method bevy::prelude::Curve::map"><code>Curve::map</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.PingPongCurve.html" title="struct bevy::math::curve::PingPongCurve">Ping<wbr>Pong<wbr>Curve</a></div><div class="desc docblock-short">The curve that results from chaining a curve with its reversed version. The transition point
is guaranteed to make no jump.</div></li><li><div class="item-name"><a class="struct" href="struct.ReparamCurve.html" title="struct bevy::math::curve::ReparamCurve">Reparam<wbr>Curve</a></div><div class="desc docblock-short">A curve whose sample space is mapped onto that of some base curve’s before sampling.
Curves of this type are produced by <a href="../../prelude/trait.Curve.html#method.reparametrize" title="method bevy::prelude::Curve::reparametrize"><code>Curve::reparametrize</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RepeatCurve.html" title="struct bevy::math::curve::RepeatCurve">Repeat<wbr>Curve</a></div><div class="desc docblock-short">The curve that results from repeating a curve <code>N</code> times.</div></li><li><div class="item-name"><a class="struct" href="struct.ReverseCurve.html" title="struct bevy::math::curve::ReverseCurve">Reverse<wbr>Curve</a></div><div class="desc docblock-short">The curve that results from reversing another.</div></li><li><div class="item-name"><a class="struct" href="struct.SampleAutoCurve.html" title="struct bevy::math::curve::SampleAutoCurve">Sample<wbr>Auto<wbr>Curve</a></div><div class="desc docblock-short">A curve that is defined by neighbor interpolation over a set of evenly-spaced samples,
interpolated automatically using <a href="../../prelude/trait.StableInterpolate.html" title="trait bevy::prelude::StableInterpolate">a particularly well-behaved interpolation</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.SampleCurve.html" title="struct bevy::math::curve::SampleCurve">Sample<wbr>Curve</a></div><div class="desc docblock-short">A curve that is defined by explicit neighbor interpolation over a set of evenly-spaced samples.</div></li><li><div class="item-name"><a class="struct" href="struct.UnevenSampleAutoCurve.html" title="struct bevy::math::curve::UnevenSampleAutoCurve">Uneven<wbr>Sample<wbr>Auto<wbr>Curve</a></div><div class="desc docblock-short">A curve that is defined by interpolation over unevenly spaced samples,
interpolated automatically using <a href="../../prelude/trait.StableInterpolate.html" title="trait bevy::prelude::StableInterpolate">a particularly well-behaved interpolation</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.UnevenSampleCurve.html" title="struct bevy::math::curve::UnevenSampleCurve">Uneven<wbr>Sample<wbr>Curve</a></div><div class="desc docblock-short">A curve that is defined by interpolation over unevenly spaced samples with explicit
interpolation.</div></li><li><div class="item-name"><a class="struct" href="struct.ZipCurve.html" title="struct bevy::math::curve::ZipCurve">ZipCurve</a></div><div class="desc docblock-short">A curve that combines the output data from two constituent curves into a tuple output. Curves
of this type are produced by <a href="../../prelude/trait.Curve.html#method.zip" title="method bevy::prelude::Curve::zip"><code>Curve::zip</code></a>.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ChainError.html" title="enum bevy::math::curve::ChainError">Chain<wbr>Error</a></div><div class="desc docblock-short">An error indicating that an end-to-end composition couldn’t be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.EaseFunction.html" title="enum bevy::math::curve::EaseFunction">Ease<wbr>Function</a></div><div class="desc docblock-short">Curve functions over the <a href="../../prelude/struct.Interval.html#associatedconstant.UNIT" title="associated constant bevy::prelude::Interval::UNIT">unit interval</a>, commonly used for easing transitions.</div></li><li><div class="item-name"><a class="enum" href="enum.LinearReparamError.html" title="enum bevy::math::curve::LinearReparamError">Linear<wbr>Reparam<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a linear reparametrization couldn’t be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.PingPongError.html" title="enum bevy::math::curve::PingPongError">Ping<wbr>Pong<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a ping ponging of a curve couldn’t be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.RepeatError.html" title="enum bevy::math::curve::RepeatError">Repeat<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a repetition of a curve couldn’t be performed because of malformed
inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.ResamplingError.html" title="enum bevy::math::curve::ResamplingError">Resampling<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a resampling operation could not be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.ReverseError.html" title="enum bevy::math::curve::ReverseError">Reverse<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a reversion of a curve couldn’t be performed because of
malformed inputs.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Curve.html" title="trait bevy::math::curve::Curve">Curve</a></div><div class="desc docblock-short">A trait for a type that can represent values of type <code>T</code> parametrized over a fixed interval.</div></li><li><div class="item-name"><a class="trait" href="trait.Ease.html" title="trait bevy::math::curve::Ease">Ease</a></div><div class="desc docblock-short">A type whose values can be eased between.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.interval.html" title="fn bevy::math::curve::interval">interval</a></div><div class="desc docblock-short">Create an <a href="../../prelude/struct.Interval.html" title="struct bevy::prelude::Interval"><code>Interval</code></a> with a given <code>start</code> and <code>end</code>. Alias of <a href="../../prelude/struct.Interval.html#method.new" title="associated function bevy::prelude::Interval::new"><code>Interval::new</code></a>.</div></li></ul></section></div></main></body></html>