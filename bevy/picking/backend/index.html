<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module provides a simple interface for implementing a picking backend."><title>bevy::picking::backend - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bevy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../../bevy/index.html">bevy</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module backend</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#implementation" title="Implementation">Implementation</a><ul><li><a href="#raycasting-backends" title="Raycasting Backends">Raycasting Backends</a></li></ul></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In bevy::<wbr>picking</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">bevy</a>::<wbr><a href="../index.html">picking</a></span><h1>Module <span>backend</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/bevy_picking/lib.rs.html#155">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module provides a simple interface for implementing a picking backend.</p>
<p>Don’t be dissuaded by terminology like “backend”; the idea is dead simple. <code>bevy_picking</code>
will tell you where pointers are, all you have to do is send an event if the pointers are
hitting something. That’s it. The rest of this documentation explains the requirements in more
detail.</p>
<p>Because <code>bevy_picking</code> is very loosely coupled with its backends, you can mix and match as
many backends as you want. For example, You could use the <code>rapier</code> backend to raycast against
physics objects, a picking shader backend to pick non-physics meshes, and the <code>bevy_ui</code> backend
for your UI. The <a href="struct.PointerHits.html" title="struct bevy::picking::backend::PointerHits"><code>PointerHits</code></a>s produced by these various backends will be combined, sorted,
and used as a homogeneous input for the picking systems that consume these events.</p>
<h3 id="implementation"><a class="doc-anchor" href="#implementation">§</a>Implementation</h3>
<ul>
<li>
<p>A picking backend only has one job: read <a href="../pointer/struct.PointerLocation.html" title="struct bevy::picking::pointer::PointerLocation"><code>PointerLocation</code></a>
components and produce <a href="struct.PointerHits.html" title="struct bevy::picking::backend::PointerHits"><code>PointerHits</code></a> events. In plain English, a backend is provided the
location of pointers, and is asked to provide a list of entities under those pointers.</p>
</li>
<li>
<p>The <a href="struct.PointerHits.html" title="struct bevy::picking::backend::PointerHits"><code>PointerHits</code></a> events produced by a backend do <strong>not</strong> need to be sorted or filtered, all
that is needed is an unordered list of entities and their <a href="struct.HitData.html" title="struct bevy::picking::backend::HitData"><code>HitData</code></a>.</p>
</li>
<li>
<p>Backends do not need to consider the <a href="../../prelude/struct.PickingBehavior.html" title="struct bevy::prelude::PickingBehavior"><code>PickingBehavior</code></a> component, though they may
use it for optimization purposes. For example, a backend that traverses a spatial hierarchy
may want to early exit if it intersects an entity that blocks lower entities from being
picked.</p>
</li>
</ul>
<h4 id="raycasting-backends"><a class="doc-anchor" href="#raycasting-backends">§</a>Raycasting Backends</h4>
<p>Backends that require a ray to cast into the scene should use <a href="prelude/struct.RayMap.html" title="struct bevy::picking::backend::prelude::RayMap"><code>ray::RayMap</code></a>. This
automatically constructs rays in world space for all cameras and pointers, handling details like
viewports and DPI for you.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod bevy::picking::backend::prelude">prelude</a></div><div class="desc docblock-short">The picking backend prelude.</div></li><li><div class="item-name"><a class="mod" href="ray/index.html" title="mod bevy::picking::backend::ray">ray</a></div><div class="desc docblock-short">Types and systems for constructing rays from cameras and pointers.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.HitData.html" title="struct bevy::picking::backend::HitData">HitData</a></div><div class="desc docblock-short">Holds data from a successful pointer hit test. See <a href="struct.HitData.html#structfield.depth" title="field bevy::picking::backend::HitData::depth"><code>HitData::depth</code></a> for important details.</div></li><li><div class="item-name"><a class="struct" href="struct.PointerHits.html" title="struct bevy::picking::backend::PointerHits">Pointer<wbr>Hits</a></div><div class="desc docblock-short">An event produced by a picking backend after it has run its hit tests, describing the entities
under a pointer.</div></li></ul></section></div></main></body></html>