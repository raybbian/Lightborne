<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Reflection in Rust."><title>bevy::reflect - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bevy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../../crates.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../bevy/index.html">bevy</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#the-reflect-and-partialreflect-traits" title="The `Reflect` and `PartialReflect` traits">The <code>Reflect</code> and <code>PartialReflect</code> traits</a><ul><li><a href="#converting-between-partialreflect-and-reflect" title="Converting between `PartialReflect` and `Reflect`">Converting between <code>PartialReflect</code> and <code>Reflect</code></a></li></ul></li><li><a href="#implementing-reflect" title="Implementing `Reflect`">Implementing <code>Reflect</code></a><ul><li><a href="#requirements" title="Requirements">Requirements</a></li></ul></li><li><a href="#the-reflection-subtraits" title="The Reflection Subtraits">The Reflection Subtraits</a><ul><li><a href="#opaque-types" title="Opaque Types">Opaque Types</a></li></ul></li><li><a href="#dynamic-types" title="Dynamic Types">Dynamic Types</a><ul><li><a href="#patching" title="Patching">Patching</a></li><li><a href="#fromreflect" title="`FromReflect`"><code>FromReflect</code></a></li></ul></li><li><a href="#path-navigation" title="Path navigation">Path navigation</a></li><li><a href="#type-registration" title="Type Registration">Type Registration</a><ul><li><a href="#reflecting-traits" title="Reflecting Traits">Reflecting Traits</a></li></ul></li><li><a href="#serialization" title="Serialization">Serialization</a></li><li><a href="#limitations" title="Limitations">Limitations</a><ul><li><a href="#non-static-lifetimes" title="Non-Static Lifetimes">Non-Static Lifetimes</a></li><li><a href="#generic-function-reflection" title="Generic Function Reflection">Generic Function Reflection</a></li><li><a href="#manual-registration" title="Manual Registration">Manual Registration</a></li></ul></li><li><a href="#features" title="Features">Features</a><ul><li><a href="#bevy" title="`bevy`"><code>bevy</code></a></li><li><a href="#functions" title="`functions`"><code>functions</code></a></li><li><a href="#documentation" title="`documentation`"><code>documentation</code></a></li><li><a href="#debug" title="`debug`"><code>debug</code></a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions-1" title="Functions">Functions</a></li><li><a href="#attributes" title="Attribute Macros">Attribute Macros</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">bevy</a></span><h1>Crate <span>reflect</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bevy_reflect/lib.rs.html#2-3126">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Reflection in Rust.</p>
<p><a href="https://en.wikipedia.org/wiki/Reflective_programming">Reflection</a> is a powerful tool provided within many programming languages
that allows for meta-programming: using information <em>about</em> the program to
<em>affect</em> the program.
In other words, reflection allows us to inspect the program itself, its
syntax, and its type information at runtime.</p>
<p>This crate adds this missing reflection functionality to Rust.
Though it was made with the <a href="https://bevyengine.org/">Bevy</a> game engine in mind,
it’s a general-purpose solution that can be used in any Rust project.</p>
<p>At a very high level, this crate allows you to:</p>
<ul>
<li>Dynamically interact with Rust values</li>
<li>Access type metadata at runtime</li>
<li>Serialize and deserialize (i.e. save and load) data</li>
</ul>
<p>It’s important to note that because of missing features in Rust,
there are some <a href="#limitations">limitations</a> with this crate.</p>
<h2 id="the-reflect-and-partialreflect-traits"><a class="doc-anchor" href="#the-reflect-and-partialreflect-traits">§</a>The <code>Reflect</code> and <code>PartialReflect</code> traits</h2>
<p>At the root of <a href="index.html" title="mod bevy::reflect"><code>bevy_reflect</code></a> is the <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> trait.</p>
<p>Its purpose is to allow dynamic <a href="https://en.wikipedia.org/wiki/Type_introspection">introspection</a> of values,
following Rust’s type system through a system of <a href="#the-reflection-subtraits">subtraits</a>.</p>
<p>Its primary purpose is to allow all implementors to be passed around
as a <code>dyn PartialReflect</code> trait object in one of the following forms:</p>
<ul>
<li><code>&amp;dyn PartialReflect</code></li>
<li><code>&amp;mut dyn PartialReflect</code></li>
<li><code>Box&lt;dyn PartialReflect&gt;</code></li>
</ul>
<p>This allows values of types implementing <code>PartialReflect</code>
to be operated upon completely dynamically (at a small <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">runtime cost</a>).</p>
<p>Building on <code>PartialReflect</code> is the <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a> trait.</p>
<p><code>PartialReflect</code> is a supertrait of <code>Reflect</code>
so any type implementing <code>Reflect</code> implements <code>PartialReflect</code> by definition.
<code>dyn Reflect</code> trait objects can be used similarly to <code>dyn PartialReflect</code>,
but <code>Reflect</code> is also often used in trait bounds (like <code>T: Reflect</code>).</p>
<p>The distinction between <code>PartialReflect</code> and <code>Reflect</code> is summarized in the following:</p>
<ul>
<li><code>PartialReflect</code> is a trait for interacting with values under <code>bevy_reflect</code>’s data model.
This means values implementing <code>PartialReflect</code> can be dynamically constructed and introspected.</li>
<li>The <code>Reflect</code> trait, however, ensures that the interface exposed by <code>PartialReflect</code>
on types which additionally implement <code>Reflect</code> mirrors the structure of a single Rust type.</li>
<li>This means <code>dyn Reflect</code> trait objects can be directly downcasted to concrete types,
where <code>dyn PartialReflect</code> trait object cannot.</li>
<li><code>Reflect</code>, since it provides a stronger type-correctness guarantee,
is the trait used to interact with <a href="#type-registration">the type registry</a>.</li>
</ul>
<h3 id="converting-between-partialreflect-and-reflect"><a class="doc-anchor" href="#converting-between-partialreflect-and-reflect">§</a>Converting between <code>PartialReflect</code> and <code>Reflect</code></h3>
<p>Since <code>T: Reflect</code> implies <code>T: PartialReflect</code>, conversion from a <code>dyn Reflect</code> to a <code>dyn PartialReflect</code>
trait object (upcasting) is infallible and can be performed with one of the following methods.
Note that these are temporary while <a href="https://github.com/rust-lang/rust/issues/65991">the language feature for dyn upcasting coercion</a> is experimental:</p>
<ul>
<li><a href="../prelude/trait.PartialReflect.html#tymethod.as_partial_reflect" title="method bevy::prelude::PartialReflect::as_partial_reflect"><code>PartialReflect::as_partial_reflect</code></a> for <code>&amp;dyn PartialReflect</code></li>
<li><a href="../prelude/trait.PartialReflect.html#tymethod.as_partial_reflect_mut" title="method bevy::prelude::PartialReflect::as_partial_reflect_mut"><code>PartialReflect::as_partial_reflect_mut</code></a> for <code>&amp;mut dyn PartialReflect</code></li>
<li><a href="../prelude/trait.PartialReflect.html#tymethod.into_partial_reflect" title="method bevy::prelude::PartialReflect::into_partial_reflect"><code>PartialReflect::into_partial_reflect</code></a> for <code>Box&lt;dyn PartialReflect&gt;</code></li>
</ul>
<p>For conversion in the other direction — downcasting <code>dyn PartialReflect</code> to <code>dyn Reflect</code> —
there are fallible methods:</p>
<ul>
<li><a href="../prelude/trait.PartialReflect.html#tymethod.try_as_reflect" title="method bevy::prelude::PartialReflect::try_as_reflect"><code>PartialReflect::try_as_reflect</code></a> for <code>&amp;dyn Reflect</code></li>
<li><a href="../prelude/trait.PartialReflect.html#tymethod.try_as_reflect_mut" title="method bevy::prelude::PartialReflect::try_as_reflect_mut"><code>PartialReflect::try_as_reflect_mut</code></a> for <code>&amp;mut dyn Reflect</code></li>
<li><a href="../prelude/trait.PartialReflect.html#tymethod.try_into_reflect" title="method bevy::prelude::PartialReflect::try_into_reflect"><code>PartialReflect::try_into_reflect</code></a> for <code>Box&lt;dyn Reflect&gt;</code></li>
</ul>
<p>Additionally, <a href="../prelude/trait.FromReflect.html#tymethod.from_reflect" title="associated function bevy::prelude::FromReflect::from_reflect"><code>FromReflect::from_reflect</code></a> can be used to convert a <code>dyn PartialReflect</code> to a concrete type
which implements <code>Reflect</code>.</p>
<h2 id="implementing-reflect"><a class="doc-anchor" href="#implementing-reflect">§</a>Implementing <code>Reflect</code></h2>
<p>Implementing <code>Reflect</code> (and <code>PartialReflect</code>) is easily done using the provided <a href="../prelude/derive.Reflect.html" title="derive bevy::prelude::Reflect">derive macro</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyStruct {
  foo: i32
}</code></pre></div>
<p>This will automatically generate the implementation of <code>Reflect</code> for any struct or enum.</p>
<p>It will also generate other very important trait implementations used for reflection:</p>
<ul>
<li><a href="trait.GetTypeRegistration.html" title="trait bevy::reflect::GetTypeRegistration"><code>GetTypeRegistration</code></a></li>
<li><a href="trait.Typed.html" title="trait bevy::reflect::Typed"><code>Typed</code></a></li>
<li><a href="../prelude/trait.Struct.html" title="trait bevy::prelude::Struct"><code>Struct</code></a>, <a href="../prelude/trait.TupleStruct.html" title="trait bevy::prelude::TupleStruct"><code>TupleStruct</code></a>, or <a href="trait.Enum.html" title="trait bevy::reflect::Enum"><code>Enum</code></a> depending on the type</li>
</ul>
<h3 id="requirements"><a class="doc-anchor" href="#requirements">§</a>Requirements</h3>
<p>We can implement <code>Reflect</code> on any type that satisfies <em>both</em> of the following conditions:</p>
<ul>
<li>The type implements <code>Any</code>, <code>Send</code>, and <code>Sync</code>.
For the <code>Any</code> requirement to be satisfied, the type itself must have a <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html#trait-bound"><code>'static</code> lifetime</a>.</li>
<li>All fields and sub-elements themselves implement <code>Reflect</code>
(see the <a href="../prelude/derive.Reflect.html" title="derive bevy::prelude::Reflect">derive macro documentation</a> for details on how to ignore certain fields when deriving).</li>
</ul>
<p>Additionally, using the derive macro on enums requires a third condition to be met:</p>
<ul>
<li>All fields and sub-elements must implement <a href="../prelude/trait.FromReflect.html" title="trait bevy::prelude::FromReflect"><code>FromReflect</code></a>—
another important reflection trait discussed in a later section.</li>
</ul>
<h2 id="the-reflection-subtraits"><a class="doc-anchor" href="#the-reflection-subtraits">§</a>The Reflection Subtraits</h2>
<p>Since <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> is meant to cover any and every type, this crate also comes with a few
more traits to accompany <code>PartialReflect</code> and provide more specific interactions.
We refer to these traits as the <em>reflection subtraits</em> since they all have <code>PartialReflect</code> as a supertrait.
The current list of reflection subtraits include:</p>
<ul>
<li><a href="trait.Tuple.html" title="trait bevy::reflect::Tuple"><code>Tuple</code></a></li>
<li><a href="trait.Array.html" title="trait bevy::reflect::Array"><code>Array</code></a></li>
<li><a href="trait.List.html" title="trait bevy::reflect::List"><code>List</code></a></li>
<li><a href="trait.Set.html" title="trait bevy::reflect::Set"><code>Set</code></a></li>
<li><a href="trait.Map.html" title="trait bevy::reflect::Map"><code>Map</code></a></li>
<li><a href="../prelude/trait.Struct.html" title="trait bevy::prelude::Struct"><code>Struct</code></a></li>
<li><a href="../prelude/trait.TupleStruct.html" title="trait bevy::prelude::TupleStruct"><code>TupleStruct</code></a></li>
<li><a href="trait.Enum.html" title="trait bevy::reflect::Enum"><code>Enum</code></a></li>
<li><a href="crate::func::Function"><code>Function</code></a> (requires the <code>functions</code> feature)</li>
</ul>
<p>As mentioned previously, the last three are automatically implemented by the <a href="../prelude/derive.Reflect.html" title="derive bevy::prelude::Reflect">derive macro</a>.</p>
<p>Each of these traits come with their own methods specific to their respective category.
For example, we can access our struct’s fields by name using the <a href="../prelude/trait.Struct.html#tymethod.field" title="method bevy::prelude::Struct::field"><code>Struct::field</code></a> method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_struct: Box&lt;<span class="kw">dyn </span>Struct&gt; = Box::new(MyStruct {
  foo: <span class="number">123
</span>});
<span class="kw">let </span>foo: <span class="kw-2">&amp;</span><span class="kw">dyn </span>PartialReflect = my_struct.field(<span class="string">"foo"</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">123</span>), foo.try_downcast_ref::&lt;i32&gt;());</code></pre></div>
<p>Since most data is passed around as <code>dyn PartialReflect</code> or <code>dyn Reflect</code> trait objects,
the <code>PartialReflect</code> trait has methods for going to and from these subtraits.</p>
<p><a href="../prelude/trait.PartialReflect.html#method.reflect_kind" title="method bevy::prelude::PartialReflect::reflect_kind"><code>PartialReflect::reflect_kind</code></a>, <a href="../prelude/trait.PartialReflect.html#tymethod.reflect_ref" title="method bevy::prelude::PartialReflect::reflect_ref"><code>PartialReflect::reflect_ref</code></a>,
<a href="../prelude/trait.PartialReflect.html#tymethod.reflect_mut" title="method bevy::prelude::PartialReflect::reflect_mut"><code>PartialReflect::reflect_mut</code></a>, and <a href="../prelude/trait.PartialReflect.html#tymethod.reflect_owned" title="method bevy::prelude::PartialReflect::reflect_owned"><code>PartialReflect::reflect_owned</code></a> all return
an enum that respectively contains zero-sized, immutable, mutable, and owned access to the type as a subtrait object.</p>
<p>For example, we can get out a <code>dyn Tuple</code> from our reflected tuple type using one of these methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_tuple: Box&lt;<span class="kw">dyn </span>PartialReflect&gt; = Box::new((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));
<span class="kw">let </span>my_tuple = my_tuple.reflect_ref().as_tuple().unwrap();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, my_tuple.field_len());</code></pre></div>
<p>And to go back to a general-purpose <code>dyn PartialReflect</code>,
we can just use the matching <a href="../prelude/trait.PartialReflect.html#tymethod.as_partial_reflect" title="method bevy::prelude::PartialReflect::as_partial_reflect"><code>PartialReflect::as_partial_reflect</code></a>, <a href="../prelude/trait.PartialReflect.html#tymethod.as_partial_reflect_mut" title="method bevy::prelude::PartialReflect::as_partial_reflect_mut"><code>PartialReflect::as_partial_reflect_mut</code></a>,
or <a href="../prelude/trait.PartialReflect.html#tymethod.into_partial_reflect" title="method bevy::prelude::PartialReflect::into_partial_reflect"><code>PartialReflect::into_partial_reflect</code></a> methods.</p>
<h3 id="opaque-types"><a class="doc-anchor" href="#opaque-types">§</a>Opaque Types</h3>
<p>Some types don’t fall under a particular subtrait.</p>
<p>These types hide their internal structure to reflection,
either because it is not possible, difficult, or not useful to reflect its internals.
Such types are known as <em>opaque</em> types.</p>
<p>This includes truly opaque types like <code>String</code> or <code>Instant</code>,
but also includes all the primitive types (e.g.  <code>bool</code>, <code>usize</code>, etc.)
since they can’t be broken down any further.</p>
<h2 id="dynamic-types"><a class="doc-anchor" href="#dynamic-types">§</a>Dynamic Types</h2>
<p>Each subtrait comes with a corresponding <em>dynamic</em> type.</p>
<p>The available dynamic types are:</p>
<ul>
<li><a href="struct.DynamicTuple.html" title="struct bevy::reflect::DynamicTuple"><code>DynamicTuple</code></a></li>
<li><a href="struct.DynamicArray.html" title="struct bevy::reflect::DynamicArray"><code>DynamicArray</code></a></li>
<li><a href="struct.DynamicList.html" title="struct bevy::reflect::DynamicList"><code>DynamicList</code></a></li>
<li><a href="struct.DynamicMap.html" title="struct bevy::reflect::DynamicMap"><code>DynamicMap</code></a></li>
<li><a href="struct.DynamicStruct.html" title="struct bevy::reflect::DynamicStruct"><code>DynamicStruct</code></a></li>
<li><a href="struct.DynamicTupleStruct.html" title="struct bevy::reflect::DynamicTupleStruct"><code>DynamicTupleStruct</code></a></li>
<li><a href="struct.DynamicEnum.html" title="struct bevy::reflect::DynamicEnum"><code>DynamicEnum</code></a></li>
</ul>
<p>These dynamic types may contain any arbitrary reflected data.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>data = DynamicStruct::default();
data.insert(<span class="string">"foo"</span>, <span class="number">123_i32</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">123</span>), data.field(<span class="string">"foo"</span>).unwrap().try_downcast_ref::&lt;i32&gt;())</code></pre></div>
<p>They are most commonly used as “proxies” for other types,
where they contain the same data as— and therefore, represent— a concrete type.
The <a href="../prelude/trait.PartialReflect.html#tymethod.clone_value" title="method bevy::prelude::PartialReflect::clone_value"><code>PartialReflect::clone_value</code></a> method will return a dynamic type for all non-opaque types,
allowing all types to essentially be “cloned”.
And since dynamic types themselves implement <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a>,
we may pass them around just like most other reflected types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>original: Box&lt;<span class="kw">dyn </span>Reflect&gt; = Box::new(MyStruct {
  foo: <span class="number">123
</span>});

<span class="comment">// `cloned` will be a `DynamicStruct` representing a `MyStruct`
</span><span class="kw">let </span>cloned: Box&lt;<span class="kw">dyn </span>PartialReflect&gt; = original.clone_value();
<span class="macro">assert!</span>(cloned.represents::&lt;MyStruct&gt;());</code></pre></div>
<h3 id="patching"><a class="doc-anchor" href="#patching">§</a>Patching</h3>
<p>These dynamic types come in handy when needing to apply multiple changes to another type.
This is known as “patching” and is done using the <a href="../prelude/trait.PartialReflect.html#method.apply" title="method bevy::prelude::PartialReflect::apply"><code>PartialReflect::apply</code></a> and <a href="../prelude/trait.PartialReflect.html#tymethod.try_apply" title="method bevy::prelude::PartialReflect::try_apply"><code>PartialReflect::try_apply</code></a> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>value = <span class="prelude-val">Some</span>(<span class="number">123_i32</span>);
<span class="kw">let </span>patch = DynamicEnum::new(<span class="string">"None"</span>, ());
value.apply(<span class="kw-2">&amp;</span>patch);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, value);</code></pre></div>
<h3 id="fromreflect"><a class="doc-anchor" href="#fromreflect">§</a><code>FromReflect</code></h3>
<p>It’s important to remember that dynamic types are <em>not</em> the concrete type they may be representing.
A common mistake is to treat them like such when trying to cast back to the original type
or when trying to make use of a reflected trait which expects the actual type.</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>original: Box&lt;<span class="kw">dyn </span>Reflect&gt; = Box::new(MyStruct {
  foo: <span class="number">123
</span>});

<span class="kw">let </span>cloned: Box&lt;<span class="kw">dyn </span>PartialReflect&gt; = original.clone_value();
<span class="kw">let </span>value = cloned.try_take::&lt;MyStruct&gt;().unwrap(); <span class="comment">// PANIC!</span></code></pre></div>
<p>To resolve this issue, we’ll need to convert the dynamic type to the concrete one.
This is where <a href="../prelude/trait.FromReflect.html" title="trait bevy::prelude::FromReflect"><code>FromReflect</code></a> comes in.</p>
<p><code>FromReflect</code> is a trait that allows an instance of a type to be generated from a
dynamic representation— even partial ones.
And since the <a href="../prelude/trait.FromReflect.html#tymethod.from_reflect" title="associated function bevy::prelude::FromReflect::from_reflect"><code>FromReflect::from_reflect</code></a> method takes the data by reference,
this can be used to effectively clone data (to an extent).</p>
<p>It is automatically implemented when <a href="../prelude/derive.Reflect.html" title="derive bevy::prelude::Reflect">deriving <code>Reflect</code></a> on a type unless opted out of
using <code>#[reflect(from_reflect = false)]</code> on the item.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyStruct {
  foo: i32
}
<span class="kw">let </span>original: Box&lt;<span class="kw">dyn </span>Reflect&gt; = Box::new(MyStruct {
  foo: <span class="number">123
</span>});

<span class="kw">let </span>cloned: Box&lt;<span class="kw">dyn </span>PartialReflect&gt; = original.clone_value();
<span class="kw">let </span>value = &lt;MyStruct <span class="kw">as </span>FromReflect&gt;::from_reflect(<span class="kw-2">&amp;*</span>cloned).unwrap(); <span class="comment">// OK!</span></code></pre></div>
<p>When deriving, all active fields and sub-elements must also implement <code>FromReflect</code>.</p>
<p>Fields can be given default values for when a field is missing in the passed value or even ignored.
Ignored fields must either implement <a href="https://doc.rust-lang.org/1.85.0/core/default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> or have a default function specified
using <code>#[reflect(default = "path::to::function")]</code>.</p>
<p>See the <a href="../prelude/derive.FromReflect.html" title="derive bevy::prelude::FromReflect">derive macro documentation</a> for details.</p>
<p>All primitives and simple types implement <code>FromReflect</code> by relying on their <a href="https://doc.rust-lang.org/1.85.0/core/default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> implementation.</p>
<h2 id="path-navigation"><a class="doc-anchor" href="#path-navigation">§</a>Path navigation</h2>
<p>The <a href="../prelude/trait.GetPath.html" title="trait bevy::prelude::GetPath"><code>GetPath</code></a> trait allows accessing arbitrary nested fields of an <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> type.</p>
<p>Using <code>GetPath</code>, it is possible to use a path string to access a specific field
of a reflected type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyStruct {
  value: Vec&lt;<span class="prelude-ty">Option</span>&lt;u32&gt;&gt;
}

<span class="kw">let </span>my_struct = MyStruct {
  value: <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="number">123</span>)],
};
<span class="macro">assert_eq!</span>(
  my_struct.path::&lt;u32&gt;(<span class="string">".value[2].0"</span>).unwrap(),
  <span class="kw-2">&amp;</span><span class="number">123</span>,
);</code></pre></div>
<h2 id="type-registration"><a class="doc-anchor" href="#type-registration">§</a>Type Registration</h2>
<p>This crate also comes with a <a href="struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry"><code>TypeRegistry</code></a> that can be used to store and retrieve additional type metadata at runtime,
such as helper types and trait implementations.</p>
<p>The <a href="../prelude/derive.Reflect.html" title="derive bevy::prelude::Reflect">derive macro</a> for <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a> also generates an implementation of the <a href="trait.GetTypeRegistration.html" title="trait bevy::reflect::GetTypeRegistration"><code>GetTypeRegistration</code></a> trait,
which is used by the registry to generate a <a href="struct.TypeRegistration.html" title="struct bevy::reflect::TypeRegistration"><code>TypeRegistration</code></a> struct for that type.
We can then register additional <a href="trait.TypeData.html" title="trait bevy::reflect::TypeData">type data</a> we want associated with that type.</p>
<p>For example, we can register <a href="../prelude/struct.ReflectDefault.html" title="struct bevy::prelude::ReflectDefault"><code>ReflectDefault</code></a> on our type so that its <code>Default</code> implementation
may be used dynamically.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect, Default)]
</span><span class="kw">struct </span>MyStruct {
  foo: i32
}
<span class="kw">let </span><span class="kw-2">mut </span>registry = TypeRegistry::empty();
registry.register::&lt;MyStruct&gt;();
registry.register_type_data::&lt;MyStruct, ReflectDefault&gt;();

<span class="kw">let </span>registration = registry.get(core::any::TypeId::of::&lt;MyStruct&gt;()).unwrap();
<span class="kw">let </span>reflect_default = registration.data::&lt;ReflectDefault&gt;().unwrap();

<span class="kw">let </span>new_value: Box&lt;<span class="kw">dyn </span>Reflect&gt; = reflect_default.default();
<span class="macro">assert!</span>(new_value.is::&lt;MyStruct&gt;());</code></pre></div>
<p>Because this operation is so common, the derive macro actually has a shorthand for it.
By using the <code>#[reflect(Trait)]</code> attribute, the derive macro will automatically register a matching,
in-scope <code>ReflectTrait</code> type within the <code>GetTypeRegistration</code> implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bevy_reflect::prelude::{Reflect, ReflectDefault};

<span class="attr">#[derive(Reflect, Default)]
#[reflect(Default)]
</span><span class="kw">struct </span>MyStruct {
  foo: i32
}</code></pre></div>
<h3 id="reflecting-traits"><a class="doc-anchor" href="#reflecting-traits">§</a>Reflecting Traits</h3>
<p>Type data doesn’t have to be tied to a trait, but it’s often extremely useful to create trait type data.
These allow traits to be used directly on a <code>dyn Reflect</code> (and not a <code>dyn PartialReflect</code>)
while utilizing the underlying type’s implementation.</p>
<p>For any <a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">object-safe</a> trait, we can easily generate a corresponding <code>ReflectTrait</code> type for our trait
using the <a href="../prelude/attr.reflect_trait.html" title="attr bevy::prelude::reflect_trait"><code>#[reflect_trait]</code></a> macro.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[reflect_trait] </span><span class="comment">// Generates a `ReflectMyTrait` type
</span><span class="kw">pub trait </span>MyTrait {}
<span class="kw">impl</span>&lt;T: Reflect&gt; MyTrait <span class="kw">for </span>T {}

<span class="kw">let </span><span class="kw-2">mut </span>registry = TypeRegistry::new();
registry.register_type_data::&lt;i32, ReflectMyTrait&gt;();</code></pre></div>
<p>The generated type data can be used to convert a valid <code>dyn Reflect</code> into a <code>dyn MyTrait</code>.
See the <a href="https://github.com/bevyengine/bevy/blob/latest/examples/reflection/trait_reflection.rs">trait reflection example</a>
for more information and usage details.</p>
<h2 id="serialization"><a class="doc-anchor" href="#serialization">§</a>Serialization</h2>
<p>By using reflection, we are also able to get serialization capabilities for free.
In fact, using <a href="index.html" title="mod bevy::reflect"><code>bevy_reflect</code></a> can result in faster compile times and reduced code generation over
directly deriving the <a href="../../serde/index.html" title="mod serde"><code>serde</code></a> traits.</p>
<p>The way it works is by moving the serialization logic into common serializers and deserializers:</p>
<ul>
<li><a href="serde/struct.ReflectSerializer.html" title="struct bevy::reflect::serde::ReflectSerializer"><code>ReflectSerializer</code></a></li>
<li><a href="serde/struct.TypedReflectSerializer.html" title="struct bevy::reflect::serde::TypedReflectSerializer"><code>TypedReflectSerializer</code></a></li>
<li><a href="serde/struct.ReflectDeserializer.html" title="struct bevy::reflect::serde::ReflectDeserializer"><code>ReflectDeserializer</code></a></li>
<li><a href="serde/struct.TypedReflectDeserializer.html" title="struct bevy::reflect::serde::TypedReflectDeserializer"><code>TypedReflectDeserializer</code></a></li>
</ul>
<p>All of these structs require a reference to the <a href="struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry">registry</a> so that <a href="enum.TypeInfo.html" title="enum bevy::reflect::TypeInfo">type information</a> can be retrieved,
as well as registered type data, such as <a href="../prelude/struct.ReflectSerialize.html" title="struct bevy::prelude::ReflectSerialize"><code>ReflectSerialize</code></a> and <a href="../prelude/struct.ReflectDeserialize.html" title="struct bevy::prelude::ReflectDeserialize"><code>ReflectDeserialize</code></a>.</p>
<p>The general entry point are the “untyped” versions of these structs.
These will automatically extract the type information and pass them into their respective “typed” version.</p>
<p>The output of the <code>ReflectSerializer</code> will be a map, where the key is the <a href="../prelude/trait.TypePath.html" title="trait bevy::prelude::TypePath">type path</a>
and the value is the serialized data.
The <code>TypedReflectSerializer</code> will simply output the serialized data.</p>
<p>The <code>ReflectDeserializer</code> can be used to deserialize this map and return a <code>Box&lt;dyn Reflect&gt;</code>,
where the underlying type will be a dynamic type representing some concrete type (except for opaque types).</p>
<p>Again, it’s important to remember that dynamic types may need to be converted to their concrete counterparts
in order to be used in certain cases.
This can be achieved using <a href="../prelude/trait.FromReflect.html" title="trait bevy::prelude::FromReflect"><code>FromReflect</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect, PartialEq, Debug)]
</span><span class="kw">struct </span>MyStruct {
  foo: i32
}

<span class="kw">let </span>original_value = MyStruct {
  foo: <span class="number">123
</span>};

<span class="comment">// Register
</span><span class="kw">let </span><span class="kw-2">mut </span>registry = TypeRegistry::new();
registry.register::&lt;MyStruct&gt;();

<span class="comment">// Serialize
</span><span class="kw">let </span>reflect_serializer = ReflectSerializer::new(original_value.as_partial_reflect(), <span class="kw-2">&amp;</span>registry);
<span class="kw">let </span>serialized_value: String = ron::to_string(<span class="kw-2">&amp;</span>reflect_serializer).unwrap();

<span class="comment">// Deserialize
</span><span class="kw">let </span>reflect_deserializer = ReflectDeserializer::new(<span class="kw-2">&amp;</span>registry);
<span class="kw">let </span>deserialized_value: Box&lt;<span class="kw">dyn </span>PartialReflect&gt; = reflect_deserializer.deserialize(
  <span class="kw-2">&amp;mut </span>ron::Deserializer::from_str(<span class="kw-2">&amp;</span>serialized_value).unwrap()
).unwrap();

<span class="comment">// Convert
</span><span class="kw">let </span>converted_value = &lt;MyStruct <span class="kw">as </span>FromReflect&gt;::from_reflect(<span class="kw-2">&amp;*</span>deserialized_value).unwrap();

<span class="macro">assert_eq!</span>(original_value, converted_value);</code></pre></div>
<h2 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h2>
<p>While this crate offers a lot in terms of adding reflection to Rust,
it does come with some limitations that don’t make it as featureful as reflection
in other programming languages.</p>
<h3 id="non-static-lifetimes"><a class="doc-anchor" href="#non-static-lifetimes">§</a>Non-Static Lifetimes</h3>
<p>One of the most obvious limitations is the <code>'static</code> requirement.
Rust requires fields to define a lifetime for referenced data,
but <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a> requires all types to have a <code>'static</code> lifetime.
This makes it impossible to reflect any type with non-static borrowed data.</p>
<h3 id="generic-function-reflection"><a class="doc-anchor" href="#generic-function-reflection">§</a>Generic Function Reflection</h3>
<p>Another limitation is the inability to reflect over generic functions directly. It can be done, but will
typically require manual monomorphization (i.e. manually specifying the types the generic method can
take).</p>
<h3 id="manual-registration"><a class="doc-anchor" href="#manual-registration">§</a>Manual Registration</h3>
<p>Since Rust doesn’t provide built-in support for running initialization code before <code>main</code>,
there is no way for <code>bevy_reflect</code> to automatically register types into the <a href="struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry">type registry</a>.
This means types must manually be registered, including their desired monomorphized
representations if generic.</p>
<h2 id="features"><a class="doc-anchor" href="#features">§</a>Features</h2><h3 id="bevy"><a class="doc-anchor" href="#bevy">§</a><code>bevy</code></h3><div><table><thead><tr><th style="text-align: center">Default</th><th style="text-align: center">Dependencies</th></tr></thead><tbody>
<tr><td style="text-align: center">❌</td><td style="text-align: center"><a href="https://docs.rs/bevy_math/latest/bevy_math/"><code>bevy_math</code></a>, <a href="https://docs.rs/glam/latest/glam/"><code>glam</code></a>, <a href="https://docs.rs/smallvec/latest/smallvec/"><code>smallvec</code></a></td></tr>
</tbody></table>
</div>
<p>This feature makes it so that the appropriate reflection traits are implemented on all the types
necessary for the <a href="https://bevyengine.org/">Bevy</a> game engine.
enables the optional dependencies: <a href="https://docs.rs/bevy_math/latest/bevy_math/"><code>bevy_math</code></a>, <a href="https://docs.rs/glam/latest/glam/"><code>glam</code></a>, and <a href="https://docs.rs/smallvec/latest/smallvec/"><code>smallvec</code></a>.
These dependencies are used by the <a href="https://bevyengine.org/">Bevy</a> game engine and must define their reflection implementations
within this crate due to Rust’s <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type:~:text=But%20we%20can%E2%80%99t,implementation%20to%20use.">orphan rule</a>.</p>
<h3 id="functions"><a class="doc-anchor" href="#functions">§</a><code>functions</code></h3><div><table><thead><tr><th style="text-align: center">Default</th><th style="text-align: center">Dependencies</th></tr></thead><tbody>
<tr><td style="text-align: center">❌</td><td style="text-align: center"><a href="../../bevy_reflect_derive/index.html" title="mod bevy_reflect_derive"><code>bevy_reflect_derive/functions</code></a></td></tr>
</tbody></table>
</div>
<p>This feature allows creating a <a href="crate::func::DynamicFunction"><code>DynamicFunction</code></a> or <a href="crate::func::DynamicFunctionMut"><code>DynamicFunctionMut</code></a> from Rust functions. Dynamic
functions can then be called with valid <a href="crate::func::ArgList"><code>ArgList</code></a>s.</p>
<p>For more information, read the [<code>func</code>] module docs.</p>
<h3 id="documentation"><a class="doc-anchor" href="#documentation">§</a><code>documentation</code></h3><div><table><thead><tr><th style="text-align: center">Default</th><th style="text-align: center">Dependencies</th></tr></thead><tbody>
<tr><td style="text-align: center">❌</td><td style="text-align: center"><a href="../../bevy_reflect_derive/index.html" title="mod bevy_reflect_derive"><code>bevy_reflect_derive/documentation</code></a></td></tr>
</tbody></table>
</div>
<p>This feature enables capturing doc comments as strings for items that <a href="../prelude/derive.Reflect.html" title="derive bevy::prelude::Reflect">derive <code>Reflect</code></a>.
Documentation information can then be accessed at runtime on the <a href="enum.TypeInfo.html" title="enum bevy::reflect::TypeInfo"><code>TypeInfo</code></a> of that item.</p>
<p>This can be useful for generating documentation for scripting language interop or
for displaying tooltips in an editor.</p>
<h3 id="debug"><a class="doc-anchor" href="#debug">§</a><code>debug</code></h3><div><table><thead><tr><th style="text-align: center">Default</th><th style="text-align: center">Dependencies</th></tr></thead><tbody>
<tr><td style="text-align: center">✅</td><td style="text-align: center"><code>debug_stack</code></td></tr>
</tbody></table>
</div>
<p>This feature enables useful debug features for reflection.</p>
<p>This includes the <code>debug_stack</code> feature,
which enables capturing the type stack when serializing or deserializing a type
and displaying it in error messages.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="access/index.html" title="mod bevy::reflect::access">access</a></div><div class="desc docblock-short">Representation for individual element accesses within a path.</div></li><li><div class="item-name"><a class="mod" href="attributes/index.html" title="mod bevy::reflect::attributes">attributes</a></div></li><li><div class="item-name"><a class="mod" href="erased_serde/index.html" title="mod bevy::reflect::erased_serde">erased_<wbr>serde</a></div><div class="desc docblock-short"><a href="https://github.com/dtolnay/erased-serde">github</a> <a href="https://crates.io/crates/erased-serde">crates-io</a> <a href="https://docs.rs/erased-serde">docs-rs</a></div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod bevy::reflect::prelude">prelude</a></div><div class="desc docblock-short">The reflect prelude.</div></li><li><div class="item-name"><a class="mod" href="serde/index.html" title="mod bevy::reflect::serde">serde</a></div></li><li><div class="item-name"><a class="mod" href="std_traits/index.html" title="mod bevy::reflect::std_traits">std_<wbr>traits</a></div></li><li><div class="item-name"><a class="mod" href="utility/index.html" title="mod bevy::reflect::utility">utility</a></div><div class="desc docblock-short">Helpers for working with Bevy reflection.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.hash_error.html" title="macro bevy::reflect::hash_error">hash_<wbr>error</a></div></li><li><div class="item-name"><a class="macro" href="macro.impl_from_reflect_opaque.html" title="macro bevy::reflect::impl_from_reflect_opaque">impl_<wbr>from_<wbr>reflect_<wbr>opaque</a></div><div class="desc docblock-short">A macro used to generate a <code>FromReflect</code> trait implementation for the given type.</div></li><li><div class="item-name"><a class="macro" href="macro.impl_reflect.html" title="macro bevy::reflect::impl_reflect">impl_<wbr>reflect</a></div><div class="desc docblock-short">A replacement for <code>#[derive(Reflect)]</code> to be used with foreign types which
the definitions of cannot be altered.</div></li><li><div class="item-name"><a class="macro" href="macro.impl_reflect_opaque.html" title="macro bevy::reflect::impl_reflect_opaque">impl_<wbr>reflect_<wbr>opaque</a></div><div class="desc docblock-short">A macro used to generate reflection trait implementations for the given type.</div></li><li><div class="item-name"><a class="macro" href="macro.impl_type_path.html" title="macro bevy::reflect::impl_type_path">impl_<wbr>type_<wbr>path</a></div><div class="desc docblock-short">A replacement for <a href="../prelude/derive.TypePath.html" title="derive bevy::prelude::TypePath">deriving <code>TypePath</code></a> for use on foreign types.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AccessError.html" title="struct bevy::reflect::AccessError">Access<wbr>Error</a></div><div class="desc docblock-short">An error originating from an <a href="enum.Access.html" title="enum bevy::reflect::Access"><code>Access</code></a> of an element within a type.</div></li><li><div class="item-name"><a class="struct" href="struct.ArrayInfo.html" title="struct bevy::reflect::ArrayInfo">Array<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time array info.</div></li><li><div class="item-name"><a class="struct" href="struct.ArrayIter.html" title="struct bevy::reflect::ArrayIter">Array<wbr>Iter</a></div><div class="desc docblock-short">An iterator over an <a href="trait.Array.html" title="trait bevy::reflect::Array"><code>Array</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ConstParamInfo.html" title="struct bevy::reflect::ConstParamInfo">Const<wbr>Param<wbr>Info</a></div><div class="desc docblock-short">Type information for a const generic parameter.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicArray.html" title="struct bevy::reflect::DynamicArray">Dynamic<wbr>Array</a></div><div class="desc docblock-short">A fixed-size list of reflected values.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicEnum.html" title="struct bevy::reflect::DynamicEnum">Dynamic<wbr>Enum</a></div><div class="desc docblock-short">A dynamic representation of an enum.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicList.html" title="struct bevy::reflect::DynamicList">Dynamic<wbr>List</a></div><div class="desc docblock-short">A list of reflected values.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicMap.html" title="struct bevy::reflect::DynamicMap">Dynamic<wbr>Map</a></div><div class="desc docblock-short">An ordered mapping between reflected values.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicSet.html" title="struct bevy::reflect::DynamicSet">Dynamic<wbr>Set</a></div><div class="desc docblock-short">An ordered set of reflected values.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicStruct.html" title="struct bevy::reflect::DynamicStruct">Dynamic<wbr>Struct</a></div><div class="desc docblock-short">A struct type which allows fields to be added at runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicTuple.html" title="struct bevy::reflect::DynamicTuple">Dynamic<wbr>Tuple</a></div><div class="desc docblock-short">A tuple which allows fields to be added at runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicTupleStruct.html" title="struct bevy::reflect::DynamicTupleStruct">Dynamic<wbr>Tuple<wbr>Struct</a></div><div class="desc docblock-short">A tuple struct which allows fields to be added at runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.EnumInfo.html" title="struct bevy::reflect::EnumInfo">Enum<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time enum info, used by <a href="enum.TypeInfo.html" title="enum bevy::reflect::TypeInfo"><code>TypeInfo</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.FieldIter.html" title="struct bevy::reflect::FieldIter">Field<wbr>Iter</a></div><div class="desc docblock-short">An iterator over the field values of a struct.</div></li><li><div class="item-name"><a class="struct" href="struct.Generics.html" title="struct bevy::reflect::Generics">Generics</a></div><div class="desc docblock-short">The generic parameters of a type.</div></li><li><div class="item-name"><a class="struct" href="struct.ListInfo.html" title="struct bevy::reflect::ListInfo">List<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time list info.</div></li><li><div class="item-name"><a class="struct" href="struct.ListIter.html" title="struct bevy::reflect::ListIter">List<wbr>Iter</a></div><div class="desc docblock-short">An iterator over an <a href="trait.List.html" title="trait bevy::reflect::List"><code>List</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.MapInfo.html" title="struct bevy::reflect::MapInfo">MapInfo</a></div><div class="desc docblock-short">A container for compile-time map info.</div></li><li><div class="item-name"><a class="struct" href="struct.MapIter.html" title="struct bevy::reflect::MapIter">MapIter</a></div><div class="desc docblock-short">An iterator over the key-value pairs of a <a href="trait.Map.html" title="trait bevy::reflect::Map"><code>Map</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.NamedField.html" title="struct bevy::reflect::NamedField">Named<wbr>Field</a></div><div class="desc docblock-short">The named field of a reflected struct.</div></li><li><div class="item-name"><a class="struct" href="struct.OffsetAccess.html" title="struct bevy::reflect::OffsetAccess">Offset<wbr>Access</a></div><div class="desc docblock-short">An <a href="enum.Access.html" title="enum bevy::reflect::Access"><code>Access</code></a> combined with an <code>offset</code> for more helpful error reporting.</div></li><li><div class="item-name"><a class="struct" href="struct.OpaqueInfo.html" title="struct bevy::reflect::OpaqueInfo">Opaque<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time info related to reflection-opaque types, including primitives.</div></li><li><div class="item-name"><a class="struct" href="struct.ParseError.html" title="struct bevy::reflect::ParseError">Parse<wbr>Error</a></div><div class="desc docblock-short">An error that occurs when parsing reflect path strings.</div></li><li><div class="item-name"><a class="struct" href="struct.ParsedPath.html" title="struct bevy::reflect::ParsedPath">Parsed<wbr>Path</a></div><div class="desc docblock-short">A pre-parsed path to an element within a type.</div></li><li><div class="item-name"><a class="struct" href="struct.ReflectDeserialize.html" title="struct bevy::reflect::ReflectDeserialize">Reflect<wbr>Deserialize</a></div><div class="desc docblock-short">A struct used to deserialize reflected instances of a type.</div></li><li><div class="item-name"><a class="struct" href="struct.ReflectFromPtr.html" title="struct bevy::reflect::ReflectFromPtr">Reflect<wbr>From<wbr>Ptr</a></div><div class="desc docblock-short"><a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a> values are commonly used in situations where the actual types of values
are not known at runtime. In such situations you might have access to a <code>*const ()</code> pointer
that you know implements <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a>, but have no way of turning it into a <code>&amp;dyn Reflect</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ReflectFromReflect.html" title="struct bevy::reflect::ReflectFromReflect">Reflect<wbr>From<wbr>Reflect</a></div><div class="desc docblock-short">Type data that represents the <a href="../prelude/trait.FromReflect.html" title="trait bevy::prelude::FromReflect"><code>FromReflect</code></a> trait and allows it to be used dynamically.</div></li><li><div class="item-name"><a class="struct" href="struct.ReflectKindMismatchError.html" title="struct bevy::reflect::ReflectKindMismatchError">Reflect<wbr>Kind<wbr>Mismatch<wbr>Error</a></div><div class="desc docblock-short">Caused when a type was expected to be of a certain <a href="enum.ReflectKind.html" title="enum bevy::reflect::ReflectKind">kind</a>, but was not.</div></li><li><div class="item-name"><a class="struct" href="struct.ReflectSerialize.html" title="struct bevy::reflect::ReflectSerialize">Reflect<wbr>Serialize</a></div><div class="desc docblock-short">A struct used to serialize reflected instances of a type.</div></li><li><div class="item-name"><a class="struct" href="struct.SetInfo.html" title="struct bevy::reflect::SetInfo">SetInfo</a></div><div class="desc docblock-short">A container for compile-time set info.</div></li><li><div class="item-name"><a class="struct" href="struct.StructInfo.html" title="struct bevy::reflect::StructInfo">Struct<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time named struct info.</div></li><li><div class="item-name"><a class="struct" href="struct.StructVariantInfo.html" title="struct bevy::reflect::StructVariantInfo">Struct<wbr>Variant<wbr>Info</a></div><div class="desc docblock-short">Type info for struct variants.</div></li><li><div class="item-name"><a class="struct" href="struct.TupleFieldIter.html" title="struct bevy::reflect::TupleFieldIter">Tuple<wbr>Field<wbr>Iter</a></div><div class="desc docblock-short">An iterator over the field values of a tuple.</div></li><li><div class="item-name"><a class="struct" href="struct.TupleInfo.html" title="struct bevy::reflect::TupleInfo">Tuple<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time tuple info.</div></li><li><div class="item-name"><a class="struct" href="struct.TupleStructFieldIter.html" title="struct bevy::reflect::TupleStructFieldIter">Tuple<wbr>Struct<wbr>Field<wbr>Iter</a></div><div class="desc docblock-short">An iterator over the field values of a tuple struct.</div></li><li><div class="item-name"><a class="struct" href="struct.TupleStructInfo.html" title="struct bevy::reflect::TupleStructInfo">Tuple<wbr>Struct<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time tuple struct info.</div></li><li><div class="item-name"><a class="struct" href="struct.TupleVariantInfo.html" title="struct bevy::reflect::TupleVariantInfo">Tuple<wbr>Variant<wbr>Info</a></div><div class="desc docblock-short">Type info for tuple variants.</div></li><li><div class="item-name"><a class="struct" href="struct.Type.html" title="struct bevy::reflect::Type">Type</a></div><div class="desc docblock-short">The base representation of a Rust type.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeParamInfo.html" title="struct bevy::reflect::TypeParamInfo">Type<wbr>Param<wbr>Info</a></div><div class="desc docblock-short">Type information for a generic type parameter.</div></li><li><div class="item-name"><a class="struct" href="struct.TypePathTable.html" title="struct bevy::reflect::TypePathTable">Type<wbr>Path<wbr>Table</a></div><div class="desc docblock-short">Provides dynamic access to all methods on <a href="../prelude/trait.TypePath.html" title="trait bevy::prelude::TypePath"><code>TypePath</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeRegistration.html" title="struct bevy::reflect::TypeRegistration">Type<wbr>Registration</a></div><div class="desc docblock-short">Runtime storage for type metadata, registered into the <a href="struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry"><code>TypeRegistry</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry">Type<wbr>Registry</a></div><div class="desc docblock-short">A registry of <a href="index.html" title="mod bevy::reflect">reflected</a> types.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeRegistryArc.html" title="struct bevy::reflect::TypeRegistryArc">Type<wbr>Registry<wbr>Arc</a></div><div class="desc docblock-short">A synchronized wrapper around a <a href="struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry"><code>TypeRegistry</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.UnitVariantInfo.html" title="struct bevy::reflect::UnitVariantInfo">Unit<wbr>Variant<wbr>Info</a></div><div class="desc docblock-short">Type info for unit variants.</div></li><li><div class="item-name"><a class="struct" href="struct.UnnamedField.html" title="struct bevy::reflect::UnnamedField">Unnamed<wbr>Field</a></div><div class="desc docblock-short">The unnamed field of a reflected tuple or tuple struct.</div></li><li><div class="item-name"><a class="struct" href="struct.VariantFieldIter.html" title="struct bevy::reflect::VariantFieldIter">Variant<wbr>Field<wbr>Iter</a></div><div class="desc docblock-short">An iterator over the fields in the current enum variant.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Access.html" title="enum bevy::reflect::Access">Access</a></div><div class="desc docblock-short">A singular element access within a path.
Multiple accesses can be combined into a <a href="struct.ParsedPath.html" title="struct bevy::reflect::ParsedPath"><code>ParsedPath</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.AccessErrorKind.html" title="enum bevy::reflect::AccessErrorKind">Access<wbr>Error<wbr>Kind</a></div><div class="desc docblock-short">The kind of <a href="struct.AccessError.html" title="struct bevy::reflect::AccessError"><code>AccessError</code></a>, along with some kind-specific information.</div></li><li><div class="item-name"><a class="enum" href="enum.ApplyError.html" title="enum bevy::reflect::ApplyError">Apply<wbr>Error</a></div><div class="desc docblock-short">A enumeration of all error outcomes that might happen when running <a href="../prelude/trait.PartialReflect.html#tymethod.try_apply" title="method bevy::prelude::PartialReflect::try_apply"><code>try_apply</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.DynamicVariant.html" title="enum bevy::reflect::DynamicVariant">Dynamic<wbr>Variant</a></div><div class="desc docblock-short">A dynamic representation of an enum variant.</div></li><li><div class="item-name"><a class="enum" href="enum.GenericInfo.html" title="enum bevy::reflect::GenericInfo">Generic<wbr>Info</a></div><div class="desc docblock-short">An enum representing a generic parameter.</div></li><li><div class="item-name"><a class="enum" href="enum.ReflectKind.html" title="enum bevy::reflect::ReflectKind">Reflect<wbr>Kind</a></div><div class="desc docblock-short">An enumeration of the “kinds” of a reflected type.</div></li><li><div class="item-name"><a class="enum" href="enum.ReflectMut.html" title="enum bevy::reflect::ReflectMut">Reflect<wbr>Mut</a></div><div class="desc docblock-short">A mutable enumeration of <a href="enum.ReflectKind.html" title="enum bevy::reflect::ReflectKind">“kinds”</a> of a reflected type.</div></li><li><div class="item-name"><a class="enum" href="enum.ReflectOwned.html" title="enum bevy::reflect::ReflectOwned">Reflect<wbr>Owned</a></div><div class="desc docblock-short">An owned enumeration of <a href="enum.ReflectKind.html" title="enum bevy::reflect::ReflectKind">“kinds”</a> of a reflected type.</div></li><li><div class="item-name"><a class="enum" href="enum.ReflectPathError.html" title="enum bevy::reflect::ReflectPathError">Reflect<wbr>Path<wbr>Error</a></div><div class="desc docblock-short">An error returned from a failed path string query.</div></li><li><div class="item-name"><a class="enum" href="enum.ReflectRef.html" title="enum bevy::reflect::ReflectRef">Reflect<wbr>Ref</a></div><div class="desc docblock-short">An immutable enumeration of <a href="enum.ReflectKind.html" title="enum bevy::reflect::ReflectKind">“kinds”</a> of a reflected type.</div></li><li><div class="item-name"><a class="enum" href="enum.TypeInfo.html" title="enum bevy::reflect::TypeInfo">Type<wbr>Info</a></div><div class="desc docblock-short">Compile-time type information for various reflected types.</div></li><li><div class="item-name"><a class="enum" href="enum.TypeInfoError.html" title="enum bevy::reflect::TypeInfoError">Type<wbr>Info<wbr>Error</a></div><div class="desc docblock-short">A <a href="enum.TypeInfo.html" title="enum bevy::reflect::TypeInfo"><code>TypeInfo</code></a>-specific error.</div></li><li><div class="item-name"><a class="enum" href="enum.VariantField.html" title="enum bevy::reflect::VariantField">Variant<wbr>Field</a></div></li><li><div class="item-name"><a class="enum" href="enum.VariantInfo.html" title="enum bevy::reflect::VariantInfo">Variant<wbr>Info</a></div><div class="desc docblock-short">A container for compile-time enum variant info.</div></li><li><div class="item-name"><a class="enum" href="enum.VariantInfoError.html" title="enum bevy::reflect::VariantInfoError">Variant<wbr>Info<wbr>Error</a></div><div class="desc docblock-short">A <a href="enum.VariantInfo.html" title="enum bevy::reflect::VariantInfo"><code>VariantInfo</code></a>-specific error.</div></li><li><div class="item-name"><a class="enum" href="enum.VariantType.html" title="enum bevy::reflect::VariantType">Variant<wbr>Type</a></div><div class="desc docblock-short">Describes the form of an enum variant.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Array.html" title="trait bevy::reflect::Array">Array</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-array-type">array-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.DynamicTypePath.html" title="trait bevy::reflect::DynamicTypePath">Dynamic<wbr>Type<wbr>Path</a></div><div class="desc docblock-short">Dynamic dispatch for <a href="../prelude/trait.TypePath.html" title="trait bevy::prelude::TypePath"><code>TypePath</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.DynamicTyped.html" title="trait bevy::reflect::DynamicTyped">Dynamic<wbr>Typed</a></div><div class="desc docblock-short">Dynamic dispatch for <a href="trait.Typed.html" title="trait bevy::reflect::Typed"><code>Typed</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.Enum.html" title="trait bevy::reflect::Enum">Enum</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">enum-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.FromReflect.html" title="trait bevy::reflect::FromReflect">From<wbr>Reflect</a></div><div class="desc docblock-short">A trait that enables types to be dynamically constructed from reflected data.</div></li><li><div class="item-name"><a class="trait" href="trait.FromType.html" title="trait bevy::reflect::FromType">From<wbr>Type</a></div><div class="desc docblock-short">Trait used to generate <a href="trait.TypeData.html" title="trait bevy::reflect::TypeData"><code>TypeData</code></a> for trait reflection.</div></li><li><div class="item-name"><a class="trait" href="trait.GetField.html" title="trait bevy::reflect::GetField">GetField</a></div><div class="desc docblock-short">A convenience trait which combines fetching and downcasting of struct
fields.</div></li><li><div class="item-name"><a class="trait" href="trait.GetPath.html" title="trait bevy::reflect::GetPath">GetPath</a></div><div class="desc docblock-short">A trait which allows nested <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a> values to be retrieved with path strings.</div></li><li><div class="item-name"><a class="trait" href="trait.GetTupleField.html" title="trait bevy::reflect::GetTupleField">GetTuple<wbr>Field</a></div><div class="desc docblock-short">A convenience trait which combines fetching and downcasting of tuple
fields.</div></li><li><div class="item-name"><a class="trait" href="trait.GetTupleStructField.html" title="trait bevy::reflect::GetTupleStructField">GetTuple<wbr>Struct<wbr>Field</a></div><div class="desc docblock-short">A convenience trait which combines fetching and downcasting of tuple
struct fields.</div></li><li><div class="item-name"><a class="trait" href="trait.GetTypeRegistration.html" title="trait bevy::reflect::GetTypeRegistration">GetType<wbr>Registration</a></div><div class="desc docblock-short">A trait which allows a type to generate its <a href="struct.TypeRegistration.html" title="struct bevy::reflect::TypeRegistration"><code>TypeRegistration</code></a>
for registration into the <a href="struct.TypeRegistry.html" title="struct bevy::reflect::TypeRegistry"><code>TypeRegistry</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.List.html" title="trait bevy::reflect::List">List</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/book/ch08-01-vectors.html">list-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.Map.html" title="trait bevy::reflect::Map">Map</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html">map-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.PartialReflect.html" title="trait bevy::reflect::PartialReflect">Partial<wbr>Reflect</a></div><div class="desc docblock-short">The foundational trait of <a href="index.html" title="mod bevy::reflect"><code>bevy_reflect</code></a>, used for accessing and modifying data dynamically.</div></li><li><div class="item-name"><a class="trait" href="trait.Reflect.html" title="trait bevy::reflect::Reflect">Reflect</a></div><div class="desc docblock-short">A core trait of <a href="index.html" title="mod bevy::reflect"><code>bevy_reflect</code></a>, used for downcasting to concrete types.</div></li><li><div class="item-name"><a class="trait" href="trait.ReflectPath.html" title="trait bevy::reflect::ReflectPath">Reflect<wbr>Path</a></div><div class="desc docblock-short">Something that can be interpreted as a reflection path in <a href="../prelude/trait.GetPath.html" title="trait bevy::prelude::GetPath"><code>GetPath</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.ReflectRemote.html" title="trait bevy::reflect::ReflectRemote">Reflect<wbr>Remote</a></div><div class="desc docblock-short">Marks a type as a <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect">reflectable</a> wrapper for a remote type.</div></li><li><div class="item-name"><a class="trait" href="trait.Reflectable.html" title="trait bevy::reflect::Reflectable">Reflectable</a></div><div class="desc docblock-short">A catch-all trait that is bound by the core reflection traits,
useful to simplify reflection-based generic type bounds.</div></li><li><div class="item-name"><a class="trait" href="trait.Set.html" title="trait bevy::reflect::Set">Set</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashSet.html">set-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.Struct.html" title="trait bevy::reflect::Struct">Struct</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">struct-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.Tuple.html" title="trait bevy::reflect::Tuple">Tuple</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type">tuple-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.TupleStruct.html" title="trait bevy::reflect::TupleStruct">Tuple<wbr>Struct</a></div><div class="desc docblock-short">A trait used to power <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">tuple struct-like</a> operations via <a href="index.html" title="mod bevy::reflect">reflection</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.TypeData.html" title="trait bevy::reflect::TypeData">Type<wbr>Data</a></div><div class="desc docblock-short">A trait used to type-erase type metadata.</div></li><li><div class="item-name"><a class="trait" href="trait.TypePath.html" title="trait bevy::reflect::TypePath">Type<wbr>Path</a></div><div class="desc docblock-short">A static accessor to type paths and names.</div></li><li><div class="item-name"><a class="trait" href="trait.Typed.html" title="trait bevy::reflect::Typed">Typed</a></div><div class="desc docblock-short">A static accessor to compile-time type information.</div></li></ul><h2 id="functions-1" class="section-header">Functions<a href="#functions-1" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.array_apply.html" title="fn bevy::reflect::array_apply">array_<wbr>apply</a></div><div class="desc docblock-short">Applies the reflected <a href="trait.Array.html" title="trait bevy::reflect::Array">array</a> data to the given <a href="trait.Array.html" title="trait bevy::reflect::Array">array</a>.</div></li><li><div class="item-name"><a class="fn" href="fn.array_debug.html" title="fn bevy::reflect::array_debug">array_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="trait.Array.html" title="trait bevy::reflect::Array"><code>Array</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.array_hash.html" title="fn bevy::reflect::array_hash">array_<wbr>hash</a></div><div class="desc docblock-short">Returns the <code>u64</code> hash of the given <a href="trait.Array.html" title="trait bevy::reflect::Array">array</a>.</div></li><li><div class="item-name"><a class="fn" href="fn.array_partial_eq.html" title="fn bevy::reflect::array_partial_eq">array_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares two <a href="trait.Array.html" title="trait bevy::reflect::Array">arrays</a> (one concrete and one reflected) to see if they
are equal.</div></li><li><div class="item-name"><a class="fn" href="fn.array_try_apply.html" title="fn bevy::reflect::array_try_apply">array_<wbr>try_<wbr>apply</a></div><div class="desc docblock-short">Tries to apply the reflected <a href="trait.Array.html" title="trait bevy::reflect::Array">array</a> data to the given <a href="trait.Array.html" title="trait bevy::reflect::Array">array</a> and
returns a Result.</div></li><li><div class="item-name"><a class="fn" href="fn.enum_debug.html" title="fn bevy::reflect::enum_debug">enum_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="trait.Enum.html" title="trait bevy::reflect::Enum"><code>Enum</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.enum_hash.html" title="fn bevy::reflect::enum_hash">enum_<wbr>hash</a></div><div class="desc docblock-short">Returns the <code>u64</code> hash of the given <a href="trait.Enum.html" title="trait bevy::reflect::Enum">enum</a>.</div></li><li><div class="item-name"><a class="fn" href="fn.enum_partial_eq.html" title="fn bevy::reflect::enum_partial_eq">enum_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares an <a href="trait.Enum.html" title="trait bevy::reflect::Enum"><code>Enum</code></a> with a <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.list_apply.html" title="fn bevy::reflect::list_apply">list_<wbr>apply</a></div><div class="desc docblock-short">Applies the elements of <code>b</code> to the corresponding elements of <code>a</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.list_debug.html" title="fn bevy::reflect::list_debug">list_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="trait.List.html" title="trait bevy::reflect::List"><code>List</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.list_hash.html" title="fn bevy::reflect::list_hash">list_<wbr>hash</a></div><div class="desc docblock-short">Returns the <code>u64</code> hash of the given <a href="trait.List.html" title="trait bevy::reflect::List">list</a>.</div></li><li><div class="item-name"><a class="fn" href="fn.list_partial_eq.html" title="fn bevy::reflect::list_partial_eq">list_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares a <a href="trait.List.html" title="trait bevy::reflect::List"><code>List</code></a> with a <a href="../prelude/trait.Reflect.html" title="trait bevy::prelude::Reflect"><code>Reflect</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.list_try_apply.html" title="fn bevy::reflect::list_try_apply">list_<wbr>try_<wbr>apply</a></div><div class="desc docblock-short">Tries to apply the elements of <code>b</code> to the corresponding elements of <code>a</code> and
returns a Result.</div></li><li><div class="item-name"><a class="fn" href="fn.map_apply.html" title="fn bevy::reflect::map_apply">map_<wbr>apply</a></div><div class="desc docblock-short">Applies the elements of reflected map <code>b</code> to the corresponding elements of map <code>a</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.map_debug.html" title="fn bevy::reflect::map_debug">map_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="trait.Map.html" title="trait bevy::reflect::Map"><code>Map</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.map_partial_eq.html" title="fn bevy::reflect::map_partial_eq">map_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares a <a href="trait.Map.html" title="trait bevy::reflect::Map"><code>Map</code></a> with a <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.map_try_apply.html" title="fn bevy::reflect::map_try_apply">map_<wbr>try_<wbr>apply</a></div><div class="desc docblock-short">Tries to apply the elements of reflected map <code>b</code> to the corresponding elements of map <code>a</code>
and returns a Result.</div></li><li><div class="item-name"><a class="fn" href="fn.set_apply.html" title="fn bevy::reflect::set_apply">set_<wbr>apply</a></div><div class="desc docblock-short">Applies the elements of reflected set <code>b</code> to the corresponding elements of set <code>a</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.set_debug.html" title="fn bevy::reflect::set_debug">set_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="trait.Set.html" title="trait bevy::reflect::Set"><code>Set</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.set_partial_eq.html" title="fn bevy::reflect::set_partial_eq">set_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares a <a href="trait.Set.html" title="trait bevy::reflect::Set"><code>Set</code></a> with a <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.set_try_apply.html" title="fn bevy::reflect::set_try_apply">set_<wbr>try_<wbr>apply</a></div><div class="desc docblock-short">Tries to apply the elements of reflected set <code>b</code> to the corresponding elements of set <code>a</code>
and returns a Result.</div></li><li><div class="item-name"><a class="fn" href="fn.struct_debug.html" title="fn bevy::reflect::struct_debug">struct_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="../prelude/trait.Struct.html" title="trait bevy::prelude::Struct"><code>Struct</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.struct_partial_eq.html" title="fn bevy::reflect::struct_partial_eq">struct_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares a <a href="../prelude/trait.Struct.html" title="trait bevy::prelude::Struct"><code>Struct</code></a> with a <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.tuple_apply.html" title="fn bevy::reflect::tuple_apply">tuple_<wbr>apply</a></div><div class="desc docblock-short">Applies the elements of <code>b</code> to the corresponding elements of <code>a</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.tuple_debug.html" title="fn bevy::reflect::tuple_debug">tuple_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="trait.Tuple.html" title="trait bevy::reflect::Tuple"><code>Tuple</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.tuple_partial_eq.html" title="fn bevy::reflect::tuple_partial_eq">tuple_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares a <a href="trait.Tuple.html" title="trait bevy::reflect::Tuple"><code>Tuple</code></a> with a <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.tuple_struct_debug.html" title="fn bevy::reflect::tuple_struct_debug">tuple_<wbr>struct_<wbr>debug</a></div><div class="desc docblock-short">The default debug formatter for <a href="../prelude/trait.TupleStruct.html" title="trait bevy::prelude::TupleStruct"><code>TupleStruct</code></a> types.</div></li><li><div class="item-name"><a class="fn" href="fn.tuple_struct_partial_eq.html" title="fn bevy::reflect::tuple_struct_partial_eq">tuple_<wbr>struct_<wbr>partial_<wbr>eq</a></div><div class="desc docblock-short">Compares a <a href="../prelude/trait.TupleStruct.html" title="trait bevy::prelude::TupleStruct"><code>TupleStruct</code></a> with a <a href="../prelude/trait.PartialReflect.html" title="trait bevy::prelude::PartialReflect"><code>PartialReflect</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.tuple_try_apply.html" title="fn bevy::reflect::tuple_try_apply">tuple_<wbr>try_<wbr>apply</a></div><div class="desc docblock-short">Tries to apply the elements of <code>b</code> to the corresponding elements of <code>a</code> and
returns a Result.</div></li></ul><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.reflect_remote.html" title="attr bevy::reflect::reflect_remote">reflect_<wbr>remote</a></div><div class="desc docblock-short">Generates a wrapper type that can be used to “derive <code>Reflect</code>” for remote types.</div></li><li><div class="item-name"><a class="attr" href="attr.reflect_trait.html" title="attr bevy::reflect::reflect_trait">reflect_<wbr>trait</a></div><div class="desc docblock-short">A macro that automatically generates type data for traits, which their implementors can then register.</div></li></ul><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.FromReflect.html" title="derive bevy::reflect::FromReflect">From<wbr>Reflect</a></div><div class="desc docblock-short">Derives the <code>FromReflect</code> trait.</div></li><li><div class="item-name"><a class="derive" href="derive.Reflect.html" title="derive bevy::reflect::Reflect">Reflect</a></div><div class="desc docblock-short">The main derive macro used by <code>bevy_reflect</code> for deriving its <code>Reflect</code> trait.</div></li><li><div class="item-name"><a class="derive" href="derive.TypePath.html" title="derive bevy::reflect::TypePath">Type<wbr>Path</a></div><div class="desc docblock-short">Derives the <code>TypePath</code> trait, providing a stable alternative to [<code>std::any::type_name</code>].</div></li></ul></section></div></main></body></html>