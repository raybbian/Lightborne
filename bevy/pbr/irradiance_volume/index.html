<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Irradiance volumes, also known as voxel global illumination."><title>bevy::pbr::irradiance_volume - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bevy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../bevy/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../../bevy/index.html">bevy</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module irradiance_<wbr>volume</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#why-ambient-cubes" title="Why ambient cubes?">Why ambient cubes?</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In bevy::<wbr>pbr</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">bevy</a>::<wbr><a href="../index.html">pbr</a></span><h1>Module <span>irradiance_volume</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/bevy_pbr/light_probe/mod.rs.html#47">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Irradiance volumes, also known as voxel global illumination.</p>
<p>An <em>irradiance volume</em> is a cuboid voxel region consisting of
regularly-spaced precomputed samples of diffuse indirect light. They’re
ideal if you have a dynamic object such as a character that can move about
static non-moving geometry such as a level in a game, and you want that
dynamic object to be affected by the light bouncing off that static
geometry.</p>
<p>To use irradiance volumes, you need to precompute, or <em>bake</em>, the indirect
light in your scene. Bevy doesn’t currently come with a way to do this.
Fortunately, <a href="http://blender.org/">Blender</a> provides a <a href="https://docs.blender.org/manual/en/latest/render/eevee/render_settings/indirect_lighting.html">baking tool</a> as part of the Eevee
renderer, and its irradiance volumes are compatible with those used by Bevy.
The <a href="https://github.com/pcwalton/bevy-baked-gi"><code>bevy-baked-gi</code></a> project provides a tool, <code>export-blender-gi</code>, that can
extract the baked irradiance volumes from the Blender <code>.blend</code> file and
package them up into a <code>.ktx2</code> texture for use by the engine. See the
documentation in the <code>bevy-baked-gi</code> project for more details on this
workflow.</p>
<p>Like all light probes in Bevy, irradiance volumes are 1×1×1 cubes that can
be arbitrarily scaled, rotated, and positioned in a scene with the
<a href="../../prelude/struct.Transform.html" title="struct bevy::prelude::Transform"><code>bevy_transform::components::Transform</code></a> component. The 3D voxel grid will
be stretched to fill the interior of the cube, and the illumination from the
irradiance volume will apply to all fragments within that bounding region.</p>
<p>Bevy’s irradiance volumes are based on Valve’s <a href="https://advances.realtimerendering.com/s2006/Mitchell-ShadingInValvesSourceEngine.pdf"><em>ambient cubes</em></a> as used in
<em>Half-Life 2</em> (<a href="https://advances.realtimerendering.com/s2006/Mitchell-ShadingInValvesSourceEngine.pdf#page=27">Mitchell 2006, slide 27</a>). These encode a single color of
light from the six 3D cardinal directions and blend the sides together
according to the surface normal. For an explanation of why ambient cubes
were chosen over spherical harmonics, see <a href="#why-ambient-cubes">Why ambient cubes?</a> below.</p>
<p>If you wish to use a tool other than <code>export-blender-gi</code> to produce the
irradiance volumes, you’ll need to pack the irradiance volumes in the
following format. The irradiance volume of resolution <em>(Rx, Ry, Rz)</em> is
expected to be a 3D texture of dimensions <em>(Rx, 2Ry, 3Rz)</em>. The unnormalized
texture coordinate <em>(s, t, p)</em> of the voxel at coordinate <em>(x, y, z)</em> with
side <em>S</em> ∈ <em>{-X, +X, -Y, +Y, -Z, +Z}</em> is as follows:</p>
<div class="example-wrap"><pre class="language-text"><code>s = x

t = y + ⎰  0 if S ∈ {-X, -Y, -Z}
        ⎱ Ry if S ∈ {+X, +Y, +Z}

        ⎧   0 if S ∈ {-X, +X}
p = z + ⎨  Rz if S ∈ {-Y, +Y}
        ⎩ 2Rz if S ∈ {-Z, +Z}</code></pre></div>
<p>Visually, in a left-handed coordinate system with Y up, viewed from the
right, the 3D texture looks like a stacked series of voxel grids, one for
each cube side, in this order:</p>
<div><table><thead><tr><th><strong>+X</strong></th><th><strong>+Y</strong></th><th><strong>+Z</strong></th></tr></thead><tbody>
<tr><td><strong>-X</strong></td><td><strong>-Y</strong></td><td><strong>-Z</strong></td></tr>
</tbody></table>
</div>
<p>A terminology note: Other engines may refer to irradiance volumes as <em>voxel
global illumination</em>, <em>VXGI</em>, or simply as <em>light probes</em>. Sometimes <em>light
probe</em> refers to what Bevy calls a reflection probe. In Bevy, <em>light probe</em>
is a generic term that encompasses all cuboid bounding regions that capture
indirect illumination, whether based on voxels or not.</p>
<p>Note that, if binding arrays aren’t supported (e.g. on WebGPU or WebGL 2),
then only the closest irradiance volume to the view will be taken into
account during rendering. The required <code>wgpu</code> features are
<a href="../../render/render_resource/struct.WgpuFeatures.html#associatedconstant.TEXTURE_BINDING_ARRAY" title="associated constant bevy::render::render_resource::WgpuFeatures::TEXTURE_BINDING_ARRAY"><code>bevy_render::settings::WgpuFeatures::TEXTURE_BINDING_ARRAY</code></a> and
<a href="../../render/render_resource/struct.WgpuFeatures.html#associatedconstant.SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING" title="associated constant bevy::render::render_resource::WgpuFeatures::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING"><code>bevy_render::settings::WgpuFeatures::SAMPLED_TEXTURE_AND_STORAGE_BUFFER_ARRAY_NON_UNIFORM_INDEXING</code></a>.</p>
<h3 id="why-ambient-cubes"><a class="doc-anchor" href="#why-ambient-cubes">§</a>Why ambient cubes?</h3>
<p>This section describes the motivation behind the decision to use ambient
cubes in Bevy. It’s not needed to use the feature; feel free to skip it
unless you’re interested in its internal design.</p>
<p>Bevy uses <em>Half-Life 2</em>-style ambient cubes (usually abbreviated as <em>HL2</em>)
as the representation of irradiance for light probes instead of the
more-popular spherical harmonics (<em>SH</em>). This might seem to be a surprising
choice, but it turns out to work well for the specific case of voxel
sampling on the GPU. Spherical harmonics have two problems that make them
less ideal for this use case:</p>
<ol>
<li>
<p>The level 1 spherical harmonic coefficients can be negative. That
prevents the use of the efficient <a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats#RGB9_E5">RGB9E5 texture format</a>, which only
encodes unsigned floating point numbers, and forces the use of the
less-efficient <a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats#Low-bitdepth_floats">RGBA16F format</a> if hardware interpolation is desired.</p>
</li>
<li>
<p>As an alternative to RGBA16F, level 1 spherical harmonics can be
normalized and scaled to the SH0 base color, as <a href="https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/gdc2018-precomputedgiobalilluminationinfrostbite.pdf#page=53">Frostbite</a> does. This
allows them to be packed in standard LDR RGBA8 textures. However, this
prevents the use of hardware trilinear filtering, as the nonuniform scale
factor means that hardware interpolation no longer produces correct results.
The 8 texture fetches needed to interpolate between voxels can be upwards of
twice as slow as the hardware interpolation.</p>
</li>
</ol>
<p>The following chart summarizes the costs and benefits of ambient cubes,
level 1 spherical harmonics, and level 2 spherical harmonics:</p>
<div><table><thead><tr><th>Technique</th><th>HW-interpolated samples</th><th>Texel fetches</th><th>Bytes per voxel</th><th>Quality</th></tr></thead><tbody>
<tr><td>Ambient cubes</td><td>3</td><td>0</td><td>24</td><td>Medium</td></tr>
<tr><td>Level 1 SH, compressed</td><td>0</td><td>36</td><td>16</td><td>Low</td></tr>
<tr><td>Level 1 SH, uncompressed</td><td>4</td><td>0</td><td>24</td><td>Low</td></tr>
<tr><td>Level 2 SH, compressed</td><td>0</td><td>72</td><td>28</td><td>High</td></tr>
<tr><td>Level 2 SH, uncompressed</td><td>9</td><td>0</td><td>54</td><td>High</td></tr>
</tbody></table>
</div>
<p>(Note that the number of bytes per voxel can be reduced using various
texture compression methods, but the overall ratios remain similar.)</p>
<p>From these data, we can see that ambient cubes balance fast lookups (from
leveraging hardware interpolation) with relatively-small storage
requirements and acceptable quality. Hence, they were chosen for irradiance
volumes in Bevy.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.IrradianceVolume.html" title="struct bevy::pbr::irradiance_volume::IrradianceVolume">Irradiance<wbr>Volume</a></div><div class="desc docblock-short">The component that defines an irradiance volume.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.IRRADIANCE_VOLUME_SHADER_HANDLE.html" title="constant bevy::pbr::irradiance_volume::IRRADIANCE_VOLUME_SHADER_HANDLE">IRRADIANCE_<wbr>VOLUME_<wbr>SHADER_<wbr>HANDLE</a></div></li></ul></section></div></main></body></html>