searchState.loadedDescShard("parry2d", 0, "parry\nBounding volumes.\nMass properties (mass, inertia, center-of-mass) of shapes.\nCompilation flags dependent aliases for mathematical types.\nSpatial partitioning tools.\nNon-persistent geometric queries.\nShapes supported by parry.\nTransformation, simplification and decomposition of meshes.\nVarious unsorted geometrical and logical operators.\nAn Axis Aligned Bounding Box.\nA Bounding Sphere.\nTrait of bounding volumes.\nFour Aabb represented as a single SoA Aabb with SIMD …\nThe smallest bounding sphere containing this <code>Aabb</code>.\nSplits this <code>Aabb</code> along the given canonical axis.\nCasts a ray on all the Aabbs represented by <code>self</code>.\nReturns a point inside of this bounding volume. This is …\nThe center of this <code>Aabb</code>.\nThe bounding sphere center.\nThe center of all the Aabbs represented by `self``.\nComputes the intersection segment between a line and this …\nComputes the parameters of the two intersection points …\nComputes the intersections between this Aabb and the given …\nComputes the intersections between this Aabb and the given …\nComputes the intersection segment between a ray and this …\nComputes the parameters of the two intersection points …\nComputes the intersection of a segment with this Aabb.\nChecks if this bounding volume contains another one.\nLanewise check which Aabb represented by <code>self</code> contains the …\nDoes this AABB contains a point expressed in the same …\nCheck which Aabb represented by <code>self</code> contains the given …\nFree functions for some special cases of bounding-volume …\nReturns the difference between this <code>Aabb</code> and <code>rhs</code>.\nReturns the difference between this <code>Aabb</code> and <code>rhs</code>.\nDilate all the Aabbs represented by …\nComputes the distances between a point and all the Aabbs …\nComputes the distances between the origin and all the …\nThe extents of this <code>Aabb</code>.\nExtracts the Aabb stored in the given SIMD lane of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>Aabb</code> from its center and its half-extents.\nCreates a new <code>Aabb</code> from a set of points.\nThe half extents of this <code>Aabb</code>.\nThe half-extents of all the Aabbs represented by `self``.\nComputes the intersection of this <code>Aabb</code> and another one.\nChecks if this bounding volume intersect with another one.\nLanewise check which Aabb represented by <code>self</code> intersects …\nDoes this AABB intersects an AABB <code>aabb2</code> moving at velocity …\nChecks intersections between all the lanes combination …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnlarges this bounding volume.\nEnlarges this bounding volume by the given margin.\nCreates a new, enlarged version, of this bounding volume.\nThe max coordinates the Aabbs.\nMerges this bounding volume with another one. The merge is …\nMerges this bounding volume with another one.\nThe min coordinates of the Aabbs.\nCreates a new Aabb.\nCreates a new bounding sphere.\nCreates an invalid <code>Aabb</code> with <code>mins</code> components set to …\nAn invalid Aabb.\nProjects every point of <code>Aabb</code> on an arbitrary axis.\nThe bounding sphere radius.\nThe radius of all the Aabbs represented by `self``.\nReplace the <code>i-th</code> Aabb of this SIMD AAAB by the given value.\nReturns a scaled version of this Aabb.\nReturns an AABB with the same center as <code>self</code> but with …\nBuilds an SIMD aabb composed of four identical aabbs.\nSplits this <code>Aabb</code> at its center, into four parts (as in a …\nEnlarges this <code>Aabb</code> so it also contains the point <code>pt</code>.\nTighten this bounding volume.\nCreates a new, tightened version, of this bounding volume.\nMerge all the Aabb represented by <code>self</code> into a single one.\nComputes the <code>Aabb</code> bounding <code>self</code> transformed by <code>m</code>.\nTransforms this bounding sphere by <code>m</code>.\nReturn the Aabb of the <code>self</code> transformed by the given …\nComputes the vertices of this <code>Aabb</code>.\nThe volume of this <code>Aabb</code>.\nComputes the <code>Aabb</code> of a set of points.\nComputes the <code>Aabb</code> of an support mapped shape.\nComputes the <code>Aabb</code> of a set of points transformed by <code>m</code>.\nComputes a bounding sphere of the specified set of point.\nThe local mass properties of a rigid-body.\nFree functions for some special-cases of mass-properties …\nReturns the argument unchanged.\nComputes the mass properties of a ball.\nComputes the mass properties of a capsule.\nComputes the mass properties of a compound shape.\nComputes the mass properties of a convex polygon.\nComputes the mass properties of a cuboid.\nComputes the mass properties of a triangle.\nComputes the mass properties of a triangle-mesh.\nCalls <code>U::from(self)</code>.\nThe inverse of the mass of a rigid-body.\nThe inverse of the principal angular inertia of the …\nThe center of mass of a rigid-body expressed in its …\nThe mass.\nInitializes the mass properties with the given …\nThe angular inertia along the principal inertia axes and …\nChanges the mass on these mass-properties.\nTransform each element of the mass properties.\nThe world-space center of mass of the rigid-body.\nThe world-space inverse angular inertia tensor of the …\nComputes the area and center-of-mass of a convex polygon.\nComputes the area and center-of-mass of a triangle-mesh.\nThe dimension of the rotations.\nThe angular vector type.\nThe angular inertia of a rigid body.\nA matrix that represent the cross product with a given …\nThe default tolerance used for geometric operations.\nThe dimension of the space.\nThe dimension of the ambient space.\nThe transformation matrix type.\nThe matrix type.\nThe orientation type.\nThe point type.\nThe principal angular inertia of a rigid body.\nThe scalar type used throughout this crate.\nThe rotation matrix type.\nSIMD_WIDTH - 1\nThe number of lanes of a SIMD number.\nA 2D symmetric-definite-positive matrix.\nA SIMD bool with SIMD_WIDTH lanes.\nA SIMD float with SIMD_WIDTH lanes.\nA vector with a dimension equal to the maximum number of …\nThe dimension of the space multiplied by two.\nThe translation type.\nThe unit vector type.\nThe vector type.\nThe coordinates of this point, i.e., the shift from the …\nThe data storage that contains all the matrix components. …\nThe data storage that contains all the matrix components. …\nThe data storage that contains all the matrix components. …\nThe data storage that contains all the matrix components. …\nThe data storage that contains all the matrix components. …\nThe component at the first row and first column of this …\nThe component at the first row and second column of this …\nThe component at the second row and second column of this …\nThe pure rotational part of this isometry.\nThe pure translational part of this isometry.\nThe translation coordinates, i.e., how much is added to a …\nA data splitter that arranges a set of Aabbs in two sets …\nThe traversal aborts.\nThe traversal should exit immediately.\nThe traversal should exit immediately.\nA data to which an index is associated.\nThe traversal can continue.\nThe traversal should continue on the children of the …\nThe traversal should continue on the children of the …\nThe index of a node part of a Qbvh. The index of one …\nA quaternary bounding-volume-hierarchy.\nTrait used for generating the content of the leaves of the …\nA SIMD node of an SIMD Qbvh.\nData splitter for Qbvh construction that generates …\nCombination of a leaf data and its associated node’s …\nWorkspace for QBVH update.\nThe result of a best-first traversal.\nThe next action to be taken by a BVH traversal algorithm …\nTrait implemented by cost functions used by the best-first …\nThe index of an internal SIMD node of a Qbvh.\nA quaternary bounding-volume-hierarchy.\nThe status of the simultaneous traversal of two spatial …\nTrait implemented by visitor called during a simultaneous …\nThe status of the spatial partitioning structure traversal.\nTrait implemented by visitor called during the traversal …\nTrait implemented by visitor called during the traversal …\nThe leaf data-splitting function.\nIndex of the nodes of the 4 nodes represented by <code>self</code>. If …\nClears this quaternary BVH and rebuilds it from a new set …\nClears this quaternary BVH and rebuilds it from a new set …\nThe data contained in this node.\nCreates a new default instance of <code>Self</code>.\nAn empty internal node.\nAn empty leaf.\nIf all the Aabb centers have the same coordinate values …\nAllowed overlap between two leaf Aabbs.\nStatus flags for this node.\nIterate through all the elements of this generator.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the index associated to <code>self</code>.\nThe index of the SIMD node containing the addressed node.\nRetrieve all the data of the nodes with Aabbs intersecting …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWas the AABB of this node changed since the last …\nDoes the AABB of this node needs to be updated?\nIs this node a leaf?\nIterate through all the leaf data in this Qbvh.\nIterates mutably through all the leaf data in this Qbvh.\nThe SIMD lane the addressed node is associated to.\nReturns the data associated to a given leaf.\nInitialize an empty Qbvh.\nIndex of the leaf node the leaf data is associated to.\nThe Aabb of the given node.\nThe index of the node parent to the 4 nodes represented by …\nPrepare a new leaf for insertion into this QBVH (or for …\nThe raw nodes of this BVH.\nThe raw proxies of this BVH.\nRebalances the <code>Qbvh</code> tree.\nUpdate all the nodes that have been marked as dirty by …\nImmediately remove a leaf from this QBVH.\nThe Aabb of the root of this tree.\nComputes a scaled version of this Qbvh.\nSets if the AABB of this node changed since the last …\nSets if the AABB of this node needs to be updated.\nThe Aabbs of the qbvh nodes represented by this node.\nGives an idea of the number of elements this generator …\nPerforms a best-first-search on the BVH.\nPerforms a best-first-search on the BVH, starting at the …\nPerforms a simultaneous traversal of two Qbvh.\nPerforms a simultaneous traversal of two Qbvh.\nPerforms a depth-first traversal on the BVH.\nPerforms a depth-first traversal on the BVH, starting at …\nPerforms a depth-first traversal on the BVH.\nPerforms a depth-first traversal on the BVH and propagates …\nPerforms a depth-first traversal on the BVH. Passes a …\nPerforms a depth-first traversal on the BVH.\nPerforms a simultaneous traversal of two Qbvh.\nPerforms a simultaneous traversal of two Qbvh.\nCompute the next action to be taken by the …\nExecute an operation on the content of a node of the …\nExecute an operation on the content of a node of the …\nExecute an operation on the content of two nodes, one from …\nEach lane indicates if the corresponding child of the node …\nOptional results associated to each child of the node …\nThe weight associated to each child of the node being …\nA composite shape vs. composite shape workspace.\nA composite shape vs. shape workspace.\nA contact manifold between two shapes.\nA serializable workspace used by some contact-manifolds …\nThe shape-casting algorithm converged successfully.\nA custom workspace.\nA dispatcher that exposes built-in queries\nSomething went wrong during the shape-casting, likely due …\nA heightfield vs. composite shape workspace.\nA heightfield vs. shape workspace.\nThe intersect operation yielded a result, lying in the …\nThe result of a plane-intersection operation.\nThe shape being split is fully contained in the negative …\nThe shape being intersected is fully contained in the …\nA nonlinear motion from a starting isometry traveling at …\nThe shape-casting algorithm ran out of iterations before …\nThe split operation yield two results: one lying on the …\nThe two shape already overlap, or are separated by a …\nA query dispatcher for queries relying on spatial …\nThe shape being split is fully contained in the positive …\nThe shape being intersected is fully contained in the …\nDispatcher for pairwise queries.\nThe composition of two dispatchers\nA Ray.\nTraits of objects which can be transformed and tested for …\nStructure containing the result of a successful ray cast.\nThe result of a shape casting..\nConfiguration for controlling the behavior of …\nThe status of the time-of-impact computation algorithm.\nA structure representing 4 rays in an SIMD SoA fashion.\nThe result of a plane-splitting operation.\nA single contact between two shape.\nA trimesh workspace.\nEnum representing workspace data of a specific type.\nError indicating that a query is not supported between …\nData from a <code>ContactManifoldsWorkspace</code>.\nThe angular velocity of this motion.\nAppends a constant isometry to this rigid-motion.\nAppends a constant translation to this rigid-motion.\nGets the underlying workspace as an enum.\nComputes the time of impact between this transform shape …\nComputes the time of impact, and normal between this …\nComputes the time of impact between this transform shape …\nComputes the time of impact, and normal between this …\nComputes the smallest time when two shapes under …\nComputes the smallest time when two shapes under …\nComputes the smallest time of impact of two shapes under …\nComputes the smallest time of impact of two shapes under …\nConstruct a <code>QueryDispatcher</code> that falls back on <code>other</code> for …\nConstruct a <code>QueryDispatcher</code> that falls back on <code>other</code> for …\nRemoves all the contacts from <code>self</code>.\nClones <code>self</code>.\nImplementation details of the <code>closest_points</code> function.\nComputes the pair of closest points between two shapes.\nIf <code>true</code>, witness points and normals will be calculated …\nCreate a <code>NonlinearRigidMotion</code> that always return <code>pos</code>.\nImplementation details of the <code>contact</code> and <code>contacts</code> …\nComputes one pair of contact points point between two …\nComputes the contact-manifold between two convex shapes.\nCompute all the contacts between two shapes.\nThe slice of all the contacts, active or not, on this …\nCopy to <code>self</code> the geometric information from <code>contact</code>.\nUser-data associated to this contact.\nAdditional tracked data associated to this contact …\nQueries dedicated to specific pairs of shapes.\nDirection of the ray.\nThe direction of the rays represented as a single SIMD …\nThe distance between the two contact points.\nComputes the minimum distance separating two shapes.\nComputes the minimum distance separating two shapes.\nComputes the minimum distance separating two shapes.\nReturns a boxed object from a boxed trait object if the …\nReturns an <code>Arc</code>-ed object from an <code>Arc</code>-ed trait object if …\nReturns a mutable reference to the object within the trait …\nReturns an <code>Rc</code>-ed object from an <code>Rc</code>-ed trait object if the …\nReturns a reference to the object within the trait object …\nThe EPA algorithm for penetration depth computation.\nFeature at the intersection point.\nThe feature ID of the first shape involved in the contact.\nThe feature ID of the second shape involved in the contact.\nReturns the contact with the smallest distance (i.e. the …\nCreates a new tracked contact where its input may need to …\nFreezes this motion at the time <code>t</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe GJK algorithm for distance computation.\nCreate a <code>NonlinearRigidMotion</code> that always returns the …\nTests whether two shapes are intersecting.\nTests whether two shapes are intersecting.\nTests whether a ray intersects this transformed shape.\nTests whether a ray intersects this transformed shape.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransforms this ray by the inverse of the given isometry.\nReturns true if the trait object wraps an object of type …\nThe translational velocity of this motion.\nThe local-space point at which the rotational part of this …\nThe contact normal of all the contacts of this manifold, …\nThe contact normal of all the contacts of this manifold, …\nThe contact point in the local-space of the first shape.\nThe contact point in the local-space of the second shape.\nCopy data associated to contacts from <code>old_contacts</code> to the …\nCopy data associated to contacts from <code>old_contacts</code> to the …\nThe maximum time-of-impacts that can be computed.\nCreates a new tracked contact.\nCreate a new empty contact-manifold.\nInitialize a motion from a starting isometry and linear …\nCreates a new ray starting from <code>origin</code> and with the …\nCreates a new <code>RayIntersection</code>.\nThe normal at the intersection point.\nThe local-space outward normal on the first shape at the …\nThe local-space outward normal on the second shape at the …\nStarting point of the ray.\nThe origin of the rays represented as a single SIMD point.\nPoint inclusion and projection.\nComputes the point at the given parameter on this line.\nThe contacts points.\nComputes the position at time <code>t</code> of a rigid-body following …\nPrepends a constant translation to this rigid-motion.\nPrepends a constant translation to this rigid-motion.\nApplication of the Separating-Axis-Theorem (SAT).\nCreates a new SIMD ray with all its lanes filled with the …\nThe starting isometry at <code>t = 0</code>.\nThe way the shape-casting algorithm terminated.\nIf <code>false</code>, the time-of-impact algorithm will automatically …\nThe first subshape involved in this contact manifold.\nThe second subshape involved in this contact manifold.\nIf the first shape involved is a composite shape, this …\nIf the second shape involved is a composite shape, this …\nSwaps every data of this shape-casting result such that …\nClones <code>self</code> and then remove all contact points from <code>self</code>.\nThe shapes will be considered as impacting as soon as …\nThe time of impact of the ray with the object. The exact …\nThe time at which the objects touch.\nTransform <code>self.witness1</code> and <code>self.normal1</code> by <code>pos</code>.\nTransforms this ray by the given isometry.\nTranslates this ray by the given vector. Its direction is …\nAttempts to use spatial coherence to update contacts …\nAttempts to use spatial coherence to update contacts …\nVisitors for performing geometric queries exploiting …\nCreate a new empty contact-manifold with the given …\nCrates a <code>ShapeCastOptions</code> with the default values except …\nThe local-space closest point on the first shape at the …\nThe local-space closest point on the second shape at the …\nClosest points information.\nA visitor for computing the closest points between a …\nThe two objects are non-intersecting and further than a …\nThe two objects are intersecting.\nThe two objects are non-intersecting but closer than a …\nComputes the pair of closest points between two shapes.\nClosest points between balls.\nClosestPoints between a ball and a convex polyhedron.\nClosest points between a composite shape and any other …\nClosestPoints between a convex polyhedron and a ball.\nClosest points between two cuboids.\nClosest points between a cuboid and a triangle.\nClosest points between a halfspace and a support-mapped …\nClosest points between two segments.\nClosest points between two lines.\nClosest points between two lines with a custom tolerance …\nClosest points between segments.\nClosest points between two segments.\nSegment-segment closest points computation in an arbitrary …\nClosest points between a shape and a composite shape.\nClosest points between a support-mapped shape (Cuboid, …\nClosest points between support-mapped shapes (<code>Cuboid</code>, …\nClosest points between support-mapped shapes (<code>Cuboid</code>, …\nClosest points between a triangle and a cuboid.\nSwaps the two points.\nReturns the result of swapping the two points if <code>self</code> is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a visitor for computing the closest points …\nTransform the points in <code>self</code> by <code>pos1</code> and <code>pos2</code>.\nGeometric description of a contact.\nComputes one pair of contact points point between two …\nContact between balls.\nContact between a ball and a convex polyhedron.\nBest contact between a composite shape (<code>Mesh</code>, <code>Compound</code>) …\nContact between a convex polyhedron and a ball.\nContact between two cuboids.\nContact between a halfspace and a support-mapped shape …\nBest contact between a shape and a composite (<code>Mesh</code>, …\nContact between a support-mapped shape (Cuboid, …\nContact between support-mapped shapes (<code>Cuboid</code>, <code>ConvexHull</code>, …\nContact between support-mapped shapes (<code>Cuboid</code>, <code>ConvexHull</code>, …\nDistance between the two contact points.\nSwaps the points and normals of this contact.\nReturns a new contact containing the swapped points and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new contact.\nContact normal, pointing towards the exterior of the first …\nContact normal, pointing towards the exterior of the …\nPosition of the contact on the first object.\nPosition of the contact on the second object.\nTransform <code>self.point1</code> and <code>self.normal1</code> by the <code>pos</code>.\nTransform the points and normals from this contact by the …\nA visitor for computing the distance between a composite …\nA composite shape vs. composite shape workspace.\nA composite shape vs. shape workspace.\nA contact manifold between two shapes.\nA serializable workspace used by some contact-manifolds …\nThe shape-casting algorithm converged successfully.\nA custom workspace.\nWhen there is a penetration, don’t stop the shape-cast …\nSomething went wrong during the shape-casting, likely due …\nA heightfield vs. composite shape workspace.\nA heightfield vs. shape workspace.\nA visitor for checking if a composite-shape and a shape …\nA visitor for checking if a composite-shape and a shape …\nA nonlinear motion from a starting isometry traveling at …\nEnum specifying the behavior of shape-casting when there …\nA visitor used to determine the non-linear time of impact …\nConstraints of contact normals, generally for internal …\nA pair of <code>NormalConstraints</code>.\nThe shape-casting algorithm ran out of iterations before …\nThe two shape already overlap, or are separated by a …\nA Ray.\nTraits of objects which can be transformed and tested for …\nA visitor for casting a ray on a composite shape.\nA visitor for casting a ray on a composite shape.\nStructure containing the result of a successful ray cast.\nThe result of a shape casting..\nConfiguration for controlling the behavior of …\nThe status of the time-of-impact computation algorithm.\nA structure representing 4 rays in an SIMD SoA fashion.\nStop shape-casting as soon as there is a penetration.\nA visitor used to find the time-of-impact between a …\nA single contact between two shape.\nA trimesh workspace.\nEnum representing workspace data of a specific type.\nData from a <code>ContactManifoldsWorkspace</code>.\nThe angular velocity of this motion.\nGets the underlying workspace as an enum.\nComputes the time of impact between this transform shape …\nComputes the time of impact, and normal between this …\nComputes the time of impact between this transform shape …\nComputes the time of impact, and normal between this …\nComputes the smallest time when two shapes under …\nTime Of Impact of two balls under translational movement.\nTime Of Impact of a composite shape with any other shape, …\nTime Of Impact of a halfspace with a support-mapped shape …\nTime Of Impact between a moving shape and a heightfield.\nComputes the smallest time of impact of two shapes under …\nTime Of Impact of a composite shape with any other shape, …\nTime Of Impact of any shape with a composite shape, under …\nCompute the time of first impact between two support-map …\nTime Of Impact of any shape with a composite shape, under …\nTime Of Impact between a moving shape and a heightfield.\nTime Of Impact of a halfspace with a support-mapped shape …\nTime of impacts between two support-mapped shapes under …\nComputes the segment given by the intersection of a line …\nCuts a polygon with the given half-space.\nProjects two segments on one another and compute their …\nProjects two segments on one another towards the direction …\nClones <code>self</code>.\nIf <code>true</code>, witness points and normals will be calculated …\nComputes the contact manifold between two balls.\nComputes the contact manifold between two balls given as …\nComputes the contact manifold between two capsules.\nComputes the contact manifold between two capsules given …\nComputes the contact manifold between a convex shape and a …\nComputes the contact manifold between a convex shape and a …\nComputes the contact manifold between two cuboids.\nComputes the contact manifold between two cuboids …\nComputes the contact manifold between a cuboid and a …\nComputes the contact manifold between a cuboid and a …\nComputes the contact manifold between a convex shape and a …\nComputes the contact manifold between a convex shape and a …\nComputes the contact manifold between two convex shapes …\nComputes the contact manifold between two convex shapes …\nComputes the contact manifolds between two composite …\nComputes the contact manifolds between a composite shape …\nComputes the contact manifold between an heightfield and a …\nComputes the contact manifold between an heightfield and …\nComputes the contact manifold between an heightfield and a …\nComputes the contact manifold between a triangle-mesh and …\nComputes the contact manifold between a triangle-mesh an a …\nUser-data associated to this contact.\nAdditional tracked data associated to this contact …\nDirection of the ray.\nThe direction of the rays represented as a single SIMD …\nInitializes a directional <code>NonlinearShapeCastMode</code>.\nThe distance between the two contact points.\nComputes the minimum distance separating two shapes.\nDistance between balls.\nDistance between a ball and a convex polyhedron.\nSmallest distance between a composite shape and any other …\nDistance between a convex polyhedron and a ball.\nDistance between two cuboids.\nDistance between a halfspace and a support-mapped shape.\nDistance between two segments.\nSmallest distance between a shape and a composite shape.\nDistance between a support-mapped shape and a halfspace.\nDistance between support-mapped shapes.\nDistance between support-mapped shapes.\nFeature at the intersection point.\nThe feature ID of the first shape involved in the contact.\nThe feature ID of the second shape involved in the contact.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTests whether two shapes are intersecting.\nTest if a segment intersects an Aabb.\nTests if a triangle intersects an Aabb.\nIntersection test between balls.\nIntersection test between a ball and a shape implementing …\nIntersection test between a composite shape (<code>Mesh</code>, <code>Compound</code>…\nIntersection test between cuboids.\nTest if a segment intersects a cuboid.\nTests if a triangle intersects an cuboid.\nIntersection test between a halfspace and a support-mapped …\nIntersection test between a shape implementing the …\nTest if a segment intersects a cuboid.\nProximity between a shape and a composite (<code>Mesh</code>, <code>Compound</code>) …\nIntersection test between a support-mapped shape (Cuboid, …\nIntersection test between support-mapped shapes (<code>Cuboid</code>, …\nIntersection test between support-mapped shapes (<code>Cuboid</code>, …\nTests if a triangle intersects a cuboid.\nTests whether a ray intersects this transformed shape.\nTests whether a ray intersects this transformed shape.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the time_of_impact of an unbounded line with a …\nThe translational velocity of this motion.\nThe local-space point at which the rotational part of this …\nThe contact normal of all the contacts of this manifold, …\nThe contact normal of all the contacts of this manifold, …\nThe contact point in the local-space of the first shape.\nThe contact point in the local-space of the second shape.\nCast a ray on a shape using the GJK algorithm.\nThe maximum time-of-impacts that can be computed.\nInitialize a visitor for computing the distance between a …\nInitialize a visitor for checking if a composite-shape and …\nInitialize a visitor for checking if a composite-shape and …\nInitializes visitor used to determine the non-linear time …\nInitialize a visitor for casting a ray on a composite …\nInitialize a visitor for casting a ray on a composite …\nCreates a new visitor used to find the time-of-impact …\nThe normal at the intersection point.\nThe local-space outward normal on the first shape at the …\nThe local-space outward normal on the second shape at the …\nStarting point of the ray.\nThe origin of the rays represented as a single SIMD point.\nThe contacts points.\nCorrects or discards the specified normal (assumed to be …\nCorrects or discards the specified normal (assumed to be …\nApplies normal correction to the unit vectors <code>normal1</code> and …\nApplies normal correction to the unit vectors <code>normal1</code> and …\nApplies normal correction to the unit vectors <code>normal1</code> and …\nApplies normal correction to the unit vectors <code>normal1</code> and …\nCorrects in-place or discards the specified normal …\nApplies the normal constraints to <code>normal1</code> and <code>normal2</code>.\nComputes the time of impact of a ray on a ball.\nComputes the time_of_impact of a ray with a halfspace …\nThe starting isometry at <code>t = 0</code>.\nThe way the shape-casting algorithm terminated.\nIf <code>false</code>, the time-of-impact algorithm will automatically …\nThe first subshape involved in this contact manifold.\nThe second subshape involved in this contact manifold.\nIf the first shape involved is a composite shape, this …\nIf the second shape involved is a composite shape, this …\nThe shapes will be considered as impacting as soon as …\nThe time of impact of the ray with the object. The exact …\nThe time at which the objects touch.\nThe local-space closest point on the first shape at the …\nThe local-space closest point on the second shape at the …\nThe max of the <code>Shape::ccd_angular_thickness</code> of both shapes …\nThe sum of the <code>Shape::ccd_thickness</code> of both shapes …\nTwo-dimensional penetration depth queries using the …\nThe Expanding Polytope Algorithm in 2D.\nProjects the origin on a shape using the EPA algorithm.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new instance of the 2D Expanding Polytope …\nProjects the origin on boundary the given shape.\nA point of a Configuration-Space Obstacle.\nResult of the GJK algorithm when a projection of the …\nA support mapping that is the point at (0.0, 0.0, 0.0).\nA support mapping that is a single point.\nThe Minkowski sum of a shape and a ball.\nResults of the GJK algorithm.\nResult of the GJK algorithm when the origin is inside of …\nResult of the GJK algorithm when the origin is too far …\nResult of the GJK algorithm when the origin is too close …\nA simplex of dimension up to 2 using Voronoï regions for …\nAdd a point to this simplex.\nCasts a ray on a support map using the GJK algorithm.\nProjects the origin on a shape using the Separating Axis …\nTests if the given point is already a vertex of this …\nThe dimension of the smallest subspace that can contain …\nCompute the normal and the distance that can travel <code>g1</code> …\nThe absolute tolerance used by the GJK algorithm.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes the support point of the CSO of <code>g1</code> and <code>g2</code> toward …\nComputes the support point of the CSO of <code>g1</code> and <code>g2</code> toward …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum squared length of the vertices of this simplex.\nApply a function to all the vertices of this simplex.\nInitializes a CSO point with <code>orig1 - orig2</code>.\nCrates a new empty simplex.\nInitializes a CSO point with all information provided.\nThe original point on the first shape used to compute …\nThe original point on the second shape used to compute …\nCSO point where all components are set to zero.\nThe i-th point of this simplex.\nThe point on the CSO. This is equal to …\nThe dimension of the simplex before the last call to …\nThe i-th point of the simplex before the last call to …\nRetrieves the barycentric coordinate associated to the <code>i</code>…\nRetrieves the barycentric coordinate associated to the <code>i</code>…\nProjects the origin on the boundary of the given shape.\nCompute the projection of the origin on the boundary of …\nProjects the origin on the boundary of this simplex and …\nThe radius of the ball involved in the Minkoski sum.\nResets this simplex to a single point.\nThe shape involved in the Minkowski sum.\nInitializes a CSO point where both original points are …\nSwap two vertices of this simplex.\nTranslate the CSO point.\nTranslate in-place the CSO point.\nAdditional shape-specific projection information\nA visitor for the projection of a point on a composite …\nA visitor for the projection of a point on a composite …\nA visitor for the projection of a point on a composite …\nDescription of the projection of a point on a shape.\nTrait of objects that can be tested for point inclusion …\nReturns shape-specific info in addition to generic …\nTests if the given point is inside of <code>self</code>.\nTests if the given point is inside of <code>self</code> transformed by <code>m</code>…\nComputes the minimal distance between a point and <code>self</code>.\nComputes the minimal distance between a point and <code>self</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether or not the point to project was inside of the …\nReturns <code>true</code> if <code>Self::is_inside</code> is <code>true</code> or if the distance …\nProjects a point on a shape using the GJK algorithm.\nInitialize a visitor for the projection of a point on a …\nInitialize a visitor for the projection of a point on a …\nInitialize a visitor for the projection of a point on a …\nInitializes a new <code>PointProjection</code>.\nThe projection result.\nProjects a point on <code>self</code>.\nProjects a point on the boundary of <code>self</code> and returns the …\nProjects a point on <code>self</code>.\nProjects a point on <code>self</code>, with a maximum projection …\nProjects a point on <code>self</code>, unless the projection lies …\nProjects a point on <code>self</code> transformed by <code>m</code>.\nProjects a point on the boundary of <code>self</code> transformed by <code>m</code> …\nProjects a point on <code>self</code> transformed by <code>m</code>.\nProjects a point on <code>self</code> transformed by <code>m</code>, with a maximum …\nProjects a point on <code>self</code> transformed by <code>m</code>, unless the …\nTransforms <code>self.point</code> by <code>pos</code>.\nFinds the best separating normal between two cuboids.\nFinds the best separating normal between a cuboid and a …\nComputes the separation between a point and a cuboid, …\nFinds the best separating normal between a cuboid and a …\nComputes the separation along the given direction, between …\nFinds the best separating normal between a triangle and a …\nFinds the best separating normal between a triangle and a …\nSpatial partitioning data structure visitor collecting …\nSpatial partitioning data structure visitor collecting …\nSpatial partitioning data structure visitor collecting …\nBest-first traversal visitor for computing the point …\nVisitor for checking if a composite shape contains a …\nSpatial partitioning structure visitor collecting nodes …\nBounding Volume Tree visitor collecting intersections with …\nThe data contained by the nodes with bounding volumes …\nA traversal will set this to <code>true</code> if the point is inside …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe transform from the local-space of the second bounding …\nThe absolute value of the rotation matrix representing …\nCreates a new <code>AabbSetsInterferencesCollector</code>.\nCreates a new …\nCreates a new <code>BoundingVolumeIntersectionsVisitor</code>.\nInitializes a visitor that allows the computation of the …\nCreates a new visitor for the testing containment of the …\nCreates a new <code>PointIntersectionsVisitor</code>.\nCreates a new <code>RayIntersectionsVisitor</code>.\nThe point to be tested.\nThe composite shape on which the point containment test …\nA tolerance applied to the interference tests.\nCreates a new …\nAt least two adjacent triangles have opposite orientations.\nFound a triangle with two or three identical vertices.\nA Ball shape.\nA ball shape.\nA ball shape.\nIf set, the connected components of the trimesh will be …\nA capsule shape defined as a round segment.\nA capsule shape.\nA capsule shape.\nOrientation with a clockwise orientation, i.e., with a …\nA compound shape with an aabb bounding volume.\nA Compound shape.\nA Compound shape.\nA 2D convex polygon.\nOrientation with a clockwise orientation, i.e., with a …\nShape of a box.\nA cuboid shape.\nA cuboid shape.\nA custom user-defined shape.\nA custom user-defined shape.\nIf set, any triangle that results in a failing half-hedge …\nIf set, the triangles sharing two vertices with identical …\nIf set, two triangles sharing three vertices with …\nDegenerate triangle.\nIf set, a special treatment will be applied to contact …\nShape-dependent identifier of a face.\nAn identifier of a feature of a convex polyhedron.\nIf set, the half-edge topology of the trimesh will be …\nA half-space delimited by an infinite plane.\nA shape representing a full half-space.\nA shape representing a full half-space.\nA 2D heightfield with a generic storage buffer for its …\nA heightfield shape.\nA heightfield shape.\nIndicates if a cell of a heightfield is removed or not. …\nIf set, the duplicate vertices of the trimesh will be …\nIf set, the trimesh will be assumed to be oriented (with …\nThe point lies on the segment interior.\nThe point lies on an edge.\nThe point lies on the triangle interior.\nThe point lies on the triangle interior (for “solid” …\nThe point lies on a vertex.\nThe point lies on a vertex.\nA feature id where the feature type is packed into the …\nA polygonal feature representing the local polygonal …\nTrait implemented by convex shapes with features with …\nA polyline.\nA set of segments.\nA set of segments.\nA convex polygon dilated by a sphere (so it has round …\nA convex polygon with rounded corners.\nA convex polygon with rounded corners.\nA cuboid dilated by a sphere (so it has round corners).\nA cuboid with rounded corners.\nA cuboid with rounded corners.\nA shape with rounded borders.\nA triangle dilated by a sphere (so it has round corners).\nA triangle with rounded corners.\nA triangle with rounded corners.\nA segment shape.\nA segment shape.\nA segment shape.\nLogical description of the location of a point on a …\nTrait implemented by shapes usable by Rapier.\nEnum representing the type of a shape.\nThe shape of a collider.\nTrait implemented by shapes composed of multiple simpler …\nTraits of convex shapes representable by a support mapping …\nA face of a triangle-mesh’s half-edge topology.\nA half-edge of a triangle-mesh’s half-edge topology.\nA vertex of a triangle-mesh’s half-edge topology.\nIndicated an inconsistency in the topology of a triangle …\nA triangle mesh.\nA triangle mesh shape.\nA triangle mesh shape.\nThe connected-components of a triangle mesh.\nThe status of the cell of an heightfield.\nThe half-edge topology information of a triangle mesh.\nA triangle shape.\nA triangle shape.\nA triangle shape.\nOrientation of a triangle.\nDescription of the location of a point on a triangle.\nThe pseudo-normals of a triangle providing approximations …\nEnum representing the shape with its actual type\nPacked feature id identifying an unknown feature.\nUnknown identifier.\nShape-dependent identifier of a vertex.\nThe segment first point.\nThe triangle first point.\nComputes the world-space <code>Aabb</code> of this ball transformed by …\nThe axis-aligned bounding box of this capsule.\nComputes the world-space <code>Aabb</code> of this cuboid, transformed …\nComputes the world-space <code>Aabb</code> of this half-space.\nCompute the axis-aligned bounding box of this polyline.\nComputes the world-space <code>Aabb</code> of this segment, transformed …\nComputes the world-space <code>Aabb</code> of this triangle, …\nComputes the world-space <code>Aabb</code> of this convex polygon, …\nComputes the world-space <code>Aabb</code> of this heightfield, …\nCompute the axis-aligned bounding box of this triangle …\nThe shapes Aabbs.\nGet a flags value with all known bits set.\nFind the index of a vertex in this triangle, such that the …\nAppends a second triangle mesh to this triangle mesh.\nThe area of this triangle.\nConverts this abstract shape to a ball, if it is one.\nConverts this abstract shape to a mutable ball, if it is …\nConverts this abstract shape to a capsule, if it is one.\nConverts this abstract shape to a mutable capsule, if it …\nConverts this abstract shape to a compound shape, if it is …\nConverts this abstract shape to a mutable compound shape, …\nConverts this abstract shape to a convex polygon, if it is …\nConverts this abstract shape to a mutable convex polygon, …\nConverts this abstract shape to a cuboid, if it is one.\nConverts this abstract shape to a mutable cuboid, if it is …\nConverts this abstract shape to a halfspace, if it is one.\nConverts this abstract shape to a halfspace, if it is one.\nConverts this abstract shape to a heightfield, if it is …\nConverts this abstract shape to a mutable heightfield, if …\nConverts this shape to a polygonal feature-map, if it is …\nConverts this abstract shape to a polyline, if it is one.\nConverts this abstract shape to a mutable polyline, if it …\nConverts this abstract shape to a round convex polygon, if …\nConverts this abstract shape to a mutable round convex …\nConverts this abstract shape to a round cuboid, if it is …\nConverts this abstract shape to a mutable round cuboid, if …\nConverts this abstract shape to a round triangle, if it is …\nConverts this abstract shape to a round triangle, if it is …\nConverts this abstract shape to a segment, if it is one.\nConverts this abstract shape to a mutable segment, if it …\nConverts this abstract shape to the given shape, if it is …\nConverts this abstract shape to the given mutable shape, …\nConverts this shape into its support mapping, if it has …\nConverts this abstract shape to a triangle, if it is one.\nConverts this abstract shape to a mutable triangle, if it …\nConverts this abstract shape to a triangle mesh, if it is …\nConverts this abstract shape to a mutable triangle mesh, …\nGets the underlying shape as an enum.\nThe segment second point.\nThe triangle second point.\nInitialize a ball shape defined by its radius.\nThe barycentric coordinates corresponding to this point …\nThe barycentric coordinates corresponding to this point …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe radius of the rounded border.\nThe radius of the rounded border.\nThe radius of the rounded border.\nThe radius of the rounded border.\nComputes the world-space bounding sphere of this ball, …\nComputes the world-space bounding sphere of this capsule, …\nComputes the world-space bounding sphere of this cuboid, …\nComputes the world-space bounding sphere of this …\nComputes the world-space bounding sphere of this polyline, …\nComputes the world-space bounding sphere of this segment, …\nComputes the world-space bounding sphere of this triangle, …\nComputes the world-space bounding sphere of this convex …\nComputes the world-space bounding sphere of this …\nComputes the world-space bounding sphere of this triangle …\nThe triangle third point.\nSplits this segment along the given canonical axis.\nThe transformation such that <code>t * Y</code> is collinear with <code>b - a</code> …\nInitialize a capsule shape from its endpoints and radius.\nInitialize a capsule shape aligned with the <code>x</code> axis.\nInitialize a capsule shape aligned with the <code>y</code> axis.\nIndex of the cell a point is on after vertical projection.\nThe width of a single cell of this heightfield.\nThe center of this capsule.\nThe geometric center of this triangle.\nThe circumcircle of this triangle.\nClones this shape into a boxed trait-object.\nClones this shape into a boxed trait-object.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nInitialize a compound shape defined by its subshapes.\nComputes the <code>Aabb</code> of this shape with the given position.\nComputes the bounding-sphere of this shape with the given …\nComputes the <code>Aabb</code> of this shape.\nComputes the bounding-sphere of this shape.\nComputes the swept <code>Aabb</code> of this shape, i.e., the space it …\nReturns the connected-component of this mesh.\nReturns the connected-component information of this …\nComputes the contacts between two polygonal features.\nWhether all set bits in a source flags value are also set …\nTests if a point is inside of this triangle.\nInitializes a compound shape obtained from the …\nInitializes a compound shape obtained from the …\nCreates a new shared shape that is the convex-hull of the …\nCreates a new shared shape that is a convex polygon formed …\nInitialize a cuboid shape defined by its half-extents.\nCreate a compound shape from the <code>TriMesh</code>. This involves …\nThe intersection of a source flags value with the …\nThe unit direction of this segment.\nReturns a boxed object from a boxed trait object if the …\nReturns an <code>Arc</code>-ed object from an <code>Arc</code>-ed trait object if …\nReturns a mutable reference to the object within the trait …\nReturns an <code>Rc</code>-ed object from an <code>Rc</code>-ed trait object if the …\nReturns a reference to the object within the trait object …\nThe three edges of this triangle: [AB, BC, CA].\nThe edges pseudo-normals, in no particular order.\nThe three edges scaled directions of this triangle: [B - …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nComputes the extents of this triangle on the given …\nExtracts the connected components of this polyline, …\nConverts a face feature id into a packed feature id.\nThe face associated to this half-edge.\nThe triangle’s face normal.\nThe <code>face_colors[i]</code> gives the connected-component index of …\nComputes the contacts between two polygonal faces.\nCompute contacts points between a face and a vertex.\nThe faces of this half-edge representation.\nThe normal of the given feature of this shape.\nThe normal of the given feature of this shape.\nThe normal of the given feature.\nThe shape’s normal at the given point located on a …\nThe shape’s normal at the given point located on a …\nGets the normal of the triangle represented by <code>feature</code>.\nThe feature ID of this polygonal feature.\nThe flags of this triangle mesh.\nA flat view of the index buffer of this mesh.\nA flat view of the index buffer of this mesh.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates the reference to a segment from the reference to …\nCreates the reference to a triangle from the reference to …\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nCreates a new 2D convex polygon from an arbitrary set of …\nCreates a new 2D convex polygon from a set of points …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nCreate a <code>TriMesh</code> from a set of points assumed to describe …\nThe set of faces grouped by connected components.\nOne of the half-edge with this vertex as endpoint.\nThe half-edge adjacent to this face, with a starting point …\nThe half-edges of this half-edge representation.\nThe half-extents of the cuboid.\nThe half-height of this capsule.\nInitialize a plane shape defined by its outward normal.\nThe height of this capsule.\nHeight of the heightfield at the given point after …\nInitializes a heightfield shape defined by its set of …\nThe height at each cell endpoint.\nThe index buffer of this mesh.\nThe index buffer of this mesh.\nThe shape being rounded.\nThe shape being rounded.\nThe shape being rounded.\nThe shape being rounded.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the trait object wraps an object of type …\nWhether all known bits in this flags value are set.\nDoes the given feature ID identify a backface of this …\nIs this shape known to be convex?\nIs this shape a <code>ConvexPolyhedron</code>?\nIs this shape a <code>ConvexPolyhedron</code>?\nWhether all bits in this flags value are unset.\nIs the identified feature a face?\nReturns <code>true</code> if the point is located on the relative …\nChecks if the i-th segment has been removed.\nIs the identified feature unknown?\nIs the identified feature a vertex?\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe length of this segment.\nComputes the local-space <code>Aabb</code> of this ball.\nThe axis-aligned bounding box of this capsule.\nThe <code>Aabb</code> of this compound in its local-space.\nComputes the local-space <code>Aabb</code> of this cuboid.\nComputes the local-space <code>Aabb</code> of this half-space.\nGets the local axis-aligned bounding box of this polyline.\nComputes the local-space <code>Aabb</code> of this segment.\nComputes the local-space <code>Aabb</code> of this triangle.\nComputes the local-space <code>Aabb</code> of this convex polygon.\nComputes the local-space <code>Aabb</code> of this heightfield.\nGets the local axis-aligned bounding box of this triangle …\nComputes the local-space Aabb of this ball.\nComputes the world-space bounding sphere of this capsule.\nThe bounding-sphere of this compound in its local-space.\nComputes the local-space bounding sphere of this cuboid.\nComputes the local-space bounding sphere of this …\nComputes the local-space bounding sphere of this polyline.\nComputes the local-space bounding sphere of this segment.\nComputes the local-space bounding sphere of this triangle.\nComputes the local-space bounding sphere of this convex …\nComputes the local-space bounding sphere of this …\nComputes the local-space bounding sphere of this triangle …\nSplits this segment by a plane identified by its normal …\nSplit a segment with a plane.\nReturn the edge segment of this cuboid with a normal cone …\nCompute the support polygonal face of <code>self</code> towards the <code>dir</code>.\nSame as <code>self.local_support_point</code> except that <code>dir</code> is …\nIf this shape is shared, then the content of <code>self</code> is …\nApplies <code>f</code> to each segment of this heightfield that …\nApplies a function to one sub-shape of this composite …\nCompute the mass-properties of this shape given its …\nCreates a new ball with the given radius.\nCreates a new capsule defined as the segment between <code>a</code> and …\nBuilds a new compound shape.\nCreates a new box from its half-extents. Half-extents are …\nBuilds a new halfspace from its center and its normal.\nCreates a new polyline from a vertex buffer and an index …\nCreates a new segment from two points.\nCreates a triangle from three points.\nCreates a new 2D heightfield with the given heights and …\nCreates a new triangle mesh from a vertex buffer and an …\nWraps the given shape as a shared shape.\nCreates a new capsule aligned with the <code>x</code> axis and with the …\nCreates a new capsule aligned with the <code>y</code> axis and with the …\nThe next half-edge.\nIn 2D, the normalized counterclockwise normal of this …\nThe halfspace planar boundary’s outward normal.\nThe normals of the edges of this convex polygon.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe number of cells of this heightfield.\nThe total number of connected components.\nThe number of segments forming this polyline.\nThe number of triangles forming this mesh.\nThe number of vertices on this polygon (must be &lt;= 4).\nReturns a mitered offset of the polygon.\nThe orientation of the triangle, based on its signed area.\nThe orientation of the 2D triangle, based on its signed …\nThe perimeter of this triangle.\nComputes the point at the given location.\nThe vertices of this convex polygon.\nInitializes a polyline shape defined by its vertex and …\nProjects the given direction to it is contained in the …\nProjects a point on <code>self</code>, with a maximum projection …\nPerform a point projection assuming a solid interior based …\nProjects a point on <code>self</code> transformed by <code>m</code>, unless the …\nGets the acceleration structure of the composite shape.\nThe acceleration structure used by this compound shape.\nThe acceleration structure used by this triangle-mesh.\nThe radius of the ball.\nThe radius of the capsule.\nThe range of connected components. …\nThe intersection of a source flags value with the …\nReverse the orientation of this polyline by swapping the …\nReverse the orientation of this triangle by swapping b and …\nReverse the orientation of the triangle mesh.\nThe <code>Aabb</code> of this heightfield.\nThe rotation <code>r</code> such that <code>r * Y</code> is collinear with <code>b - a</code>.\nInitializes a compound shape obtained from the …\nInitializes a compound shape obtained from the …\nCreates a new shared shape with rounded corners that is the\nCreates a new shared shape with round corners that is a …\nInitialize a round cuboid shape defined by its …\nInitializes a triangle shape with round corners.\nThe scale factor applied to this heightfield.\nScales this shape by <code>scale</code> into a boxed trait-object.\nComputes a scaled version of this ball.\nComputes a scaled version of this capsule.\nComputes a scaled version of this cuboid.\nComputes a scaled version of this half-space.\nComputes a scaled version of this polyline.\nComputes a scaled version of this segment.\nComputes a scaled version of this triangle.\nComputes a scaled version of this convex polygon.\nReturns a scaled version of this heightfield.\nReturns a scaled version of this triangle mesh.\nThe direction of this segment scaled by its length.\nIn 2D, the not-normalized counterclockwise normal of this …\nGet the <code>i</code>-th segment of this mesh.\nInitialize a segment shape from its endpoints.\nThe endpoints of the capsule’s principal axis.\nThe i-th segment of the heightfield if it has not been …\nTransforms  the feature-id of a segment to the feature-id …\nAn iterator through all the segments of this mesh.\nIterator through all the segments of this heightfield.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nSets the flags of this triangle mesh, controlling its …\nSets the scale factor applied to this heightfield.\nMark the i-th segment of this heightfield as removed or …\nGets the type tag of this shape.\nThe shapes of this compound shape.\nThe left-most x-coordinate of this heightfield.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nReturn the face of this cuboid with a normal that maximizes\nReturn the face of this triangle with a normal that …\nReturn the feature of this cuboid with a normal that …\nGet the ID of the feature with a normal that maximizes the …\nSame as <code>self.support_point</code> except that <code>dir</code> is normalized.\nSwaps the two vertices of this segment.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nConvert the connected-component description into actual …\nConvert the connected-component description into actual …\nDiscretize the boundary of this round cuboid as a …\nDiscretize the boundary of this round convex polygon as a …\nDiscretize the boundary of this ball as a polygonal line.\nDiscretize the boundary of this capsule as a polygonal …\nDiscretize the boundary of this cuboid as a polygonal line.\nDiscretize the boundary of this round cuboid as a …\nDiscretize the boundary of this round convex polygon as a …\nRasterize this heightfield as a (potentially …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nReturns the topology information of this trimesh, if it …\nCreates a new capsule equal to <code>self</code> with all its endpoints …\nTransforms the vertices of <code>self</code> by the given position <code>pos</code>.\nTransforms in-place the vertices of this triangle mesh.\nThe transform <code>t</code> such that <code>t * Y</code> is collinear with <code>b - a</code> …\nApplies the isometry <code>m</code> to the vertices of this segment and …\nReturns a new triangle with vertices transformed by <code>m</code>.\nGet the <code>i</code>-th triangle of this mesh.\nInitializes a triangle shape.\nAn iterator through all the triangles of this mesh.\nInitializes a triangle mesh shape defined by its vertex …\nInitializes a triangle mesh shape defined by its vertex …\nThis half-edge twin on the adjacent triangle.\nThe range of segment ids that may intersect the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nComputes the unit angular inertia of this triangle.\nThe width of a single cell of this heightfield, without …\nUnpacks this feature id into an explicit enum.\nRetrieves the value of the identifier if <code>self</code> is a face.\nRevries the value of the identifier if <code>self</code> is a vertex.\nConverts a vertex feature id into a packed feature id.\nThe first vertex of this edge.\nReturn the id of the vertex of this cuboid with a normal …\nThe vertex buffer of this mesh.\nReference to an array containing the three vertices of …\nThe vertex buffer of this mesh.\nThe vertices of this half-edge representation.\nUp to two vertices forming this polygonal feature.\nThe feature IDs of this polygon’s vertices.\nCreates a new triangle mesh from a vertex buffer and an …\nThe edge shared between the two triangles.\nThe first triangle, with an orientation opposite to the …\nThe second triangle, with an orientation opposite to the …\nComputes the convex hull of a set of 2d points.\nComputes the convex hull of a set of 2d points and returns …\nComputes the intersection of two convex polygons.\nComputes the intersection points of two convex polygons.\nComputes the intersection points of two convex polygons.\nComputes the intersection of two convex polygons.\nThe Hertel-Mehlhorn algorithm.\nInternal implementation of the Hertel-Mehlhorn algorithm …\nCompute intersections between two polygons that may be …\nCompute intersections between two polygons that may be …\nUtilities useful for various generations tasks.\nApproximate convex decomposition using the VHACD algorithm.\nVoxelization of a 2D polyline or 3D triangle mesh.\nPushes to <code>out</code> a set of points forming an arc starting at …\nPushes a discretized counterclockwise circle to a buffer. …\nReturns the transformed version of a vector of points.\nApplies in-place a transformation to an array of points.\nReturns the transformed version of a vector of points.\nApproximate convex decomposition using the VHACD algorithm.\nParameters controlling the VHACD convex decomposition.\nControls the bias toward clipping along symmetry planes.\nControls the bias toward clipping along revolution planes.\nCompute the convex hulls of the voxelized …\nCompute the convex-hulls of the parts computed by this …\nCompute the intersections between the voxelized convex …\nMaximum concavity.\nControls whether the convex-hull should be approximated …\nControls the precision of the convex-hull generation …\nDecompose the given polyline (in 2D) or triangle mesh (in …\nControls the way the input mesh or polyline is being …\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform an approximate convex decomposition of a set of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nControls the max number of convex-hull generated by the …\nControls the granularity of the search for the best …\nResolution used during the voxelization stage.\nThe almost-convex voxelized parts computed by the VHACD …\nControls how the voxelization determines which voxel needs …\nUse a flood-fill technique to consider fill the voxels …\nA voxel that is on the interior of the voxelized shape.\nIntermediate value, should be ignored by end-user code.\nVoxel that intersects the surface of the voxelized shape.\nIntermediate value, should be ignored by end-user code.\nIntermediate value, should be ignored by end-user code.\nIntermediate value, should be ignored by end-user code.\nA voxel that is outside of the voxelized shape.\nIntermediate value, should be ignored by end-user code.\nIntermediate value, should be ignored by end-user code.\nOnly consider full the voxels intersecting the surface of …\nA voxel.\nA sparse set of voxels.\nThe values of a voxel.\nA cubic volume filled with voxels.\nUpdate the bounding box of this voxel set.\nCompute the convex-hull of the voxels in this set.\nCompute the convex-hull of this voxel set after cutting …\nComputes the intersections between all the voxels of this …\nComputes the total volume of the voxels contained by this …\nThe integer coordinates of the voxel as part of the voxel …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes this voxel not contain any element?\nIs this voxel on the surface of the volume (i.e. not …\nThe number of voxels in this set.\nThe maximal coordinates of the integer bounding-box of the …\nThe minimal coordinates of the integer bounding-box of the …\nCreates a new empty set of voxels.\nThe 3D origin of this voxel-set.\nThe number of voxel subdivisions along each coordinate …\nThe scale factor that needs to be applied to the voxels of …\nThe scale factor between the voxel integer coordinates and …\nThe value of the given voxel.\nThe volume of a single voxel of this voxel set.\nVoxelizes the given shape described by its boundary: a …\nVoxelizes the given shape described by its boundary: a …\nThe set of voxels.\nDetects holes inside of a solid contour.\nAttempts to properly handle self-intersections.\nTrait that transforms thing to a slice of u8.\nA hasher builder that creates <code>DefaultHasher</code> with default …\nA structure that implements <code>Eq</code> and is hashable even if the …\nAn interval implementing interval arithmetic.\nA derivable valued function which can be bounded on …\nExtra operations with isometries.\nVarious operations usable with <code>Option&lt;Isometry&gt;</code> and …\nSingle point of intersection.\nA 2x2 symmetric-definite-positive matrix.\nA 3x3 symmetric-definite-positive matrix.\nIntersection along a segment (when both segments are …\nIntersection between two segments.\nA pair of elements sorted in increasing order.\nTransform a vector by the absolute value of the …\nAdds <code>val</code> to the diagonal components of <code>self</code>.\nAdds <code>elt</code> to the diagonal components of <code>self</code>.\nConverts <code>self</code> to a slice of bytes.\nComputes the direction pointing toward the right-hand-side …\nComputes the center of a set of point.\nComputes the center and the covariance matrix of a set of …\nDoes this interval contain the given value?\nBounds the image of the cosinus function on this interval.\nComputes the covariance matrix of a set of points.\nCreate a new SDP matrix with its diagonal filled with <code>val</code>, …\nCreate a new SDP matrix with its diagonal filled with <code>val</code>, …\nComputes a new interval that contains both <code>self</code> and <code>t</code>.\nEvaluate the function at <code>t</code>.\nBounds all the values of this function on the interval <code>t</code>.\nBounds all the values of the gradient of this function on …\nExecute the Interval Newton Method to isolate all the …\nExecute the Interval Newton Method to isolate all the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild an <code>SdpMatrix2</code> structure from a plain matrix, …\nBuild an <code>SdpMatrix3</code> structure from a plain matrix, …\nA hash-map that behaves deterministically when the …\nComputes the intersection between two intervals.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this SDP matrix to a regular matrix representation.\nComputes <code>self.inverse() * rhs</code>.\nCompute the inverse of this SDP matrix without performing …\nComputes <code>self.inverse() * p</code>.\nComputes <code>self.inverse() * v</code>.\nComputes <code>self.inverse() * v</code>.\nCompute the inverse of this SDP matrix without performing …\nCompute the inverse of this SDP matrix without performing …\nAre all components of this matrix equal to zero?\nThe component at the first row and first column of this …\nThe component at the first row and first column of this …\nThe component at the first row and second column of this …\nThe component at the first row and second column of this …\nThe component at the first row and third column of this …\nThe component at the second row and second column of this …\nThe component at the second row and second column of this …\nThe component at the second row and third column of this …\nThe component at the third row and third column of this …\nComputes the median of a set of values.\nThe average of the two interval endpoints.\nCreates a new <code>DeterministicState</code> that builds <code>DefaultHasher</code> …\nCreates a new <code>HashablePartialEq</code>. Please make sure that you …\nA new SDP 2x2 matrix with the given components.\nA new SDP 3x3 matrix with the given components.\nSorts two elements in increasing order into a new pair.\nComputes an oriented bounding box for the given set of …\nComputes the support point of a cloud of points.\nComputes the index of the support point of a cloud of …\nTests if the given point is inside a convex polygon with …\nTests if the given point is inside an arbitrary closed …\nFunction to check if a point is inside a triangle and …\nComputes <code>rhs * self</code>.\nCompute the quadratic form <code>m.transpose() * self * m</code>.\nCompute the quadratic form <code>m.transpose() * self * m</code>.\nComputes the intersection between two segments.\nBounds the image of the sinus function on this interval.\nBounds the image of the<code>sin</code> and <code>cos</code> functions on this …\nCreate the interval <code>[min(a, b), max(a, b)]</code>.\nCreate the interval <code>[e, e]</code> (single value).\nSplits this interval at its midpoint.\nComputes <code>self * p</code>.\nComputes <code>self * v</code>.\nComputes <code>self * v</code>.\nGets the wrapped value.\nThe width of this interval.\nCreate a new SDP matrix filled with zeros.\nCreate a new SDP matrix filled with zeros.\nLocation of the first intersection point on the first …\nLocation of the first intersection point on the second …\nLocation of the intersection point on the first segment.\nLocation of the intersection point on the second segment.\nLocation of the second intersection point on the first …\nLocation of the second intersection point on the second …\nA view into a single entry in a map, which may either be …\nThis is the same as FxHasher, but with the guarantee that …\nType alias for a hash map that uses the Fx hashing …\nAn occupied entry.\nA vacant entry.\nProvides in-place mutable access to an occupied entry …\nReturns the argument unchanged.\nReturns the argument unchanged.\nSets the value of the entry, and returns an <code>OccupiedEntry</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a reference to this entry’s key.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nEnsures a value is in the entry by inserting, if empty, …\nCounter-clockwise\nClockwise\nNeither (a straight line)\nThe orientation or winding direction of a corner or …\nReturns the direction of a line through <code>p1</code>, <code>p2</code> and <code>p3</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if point <code>p</code> is in triangle with corners <code>v1</code>, <code>v2</code> …")