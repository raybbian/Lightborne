<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait which allows nested `Reflect` values to be retrieved with path strings."><title>GetPath in bevy_reflect - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bevy_reflect" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../bevy_reflect/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../bevy_reflect/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../bevy_reflect/index.html">bevy_<wbr>reflect</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">GetPath</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#syntax" title="Syntax">Syntax</a><ul><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#tuples-and-tuple-structs" title="Tuples and Tuple Structs">Tuples and Tuple Structs</a></li><li><a href="#lists-and-arrays" title="Lists and Arrays">Lists and Arrays</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></li><li><a href="#chaining" title="Chaining">Chaining</a><ul><li><a href="#example-4" title="Example">Example</a></li></ul></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.path" title="path">path</a></li><li><a href="#method.path_mut" title="path_mut">path_mut</a></li><li><a href="#method.reflect_path" title="reflect_path">reflect_path</a></li><li><a href="#method.reflect_path_mut" title="reflect_path_mut">reflect_path_mut</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate bevy_<wbr>reflect</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">bevy_reflect</a></span><h1>Trait <span class="trait">GetPath</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bevy_reflect/path/mod.rs.html#239-280">Source</a> </span></div><pre class="rust item-decl"><code>pub trait GetPath: <a class="trait" href="trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a> {
    // Provided methods
    fn <a href="#method.reflect_path" class="fn">reflect_path</a>&lt;'p&gt;(
        &amp;self,
        path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;dyn <a class="trait" href="trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.reflect_path_mut" class="fn">reflect_path_mut</a>&lt;'p&gt;(
        &amp;mut self,
        path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;mut dyn <a class="trait" href="trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.path" class="fn">path</a>&lt;'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
        &amp;self,
        path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.path_mut" class="fn">path_mut</a>&lt;'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
        &amp;mut self,
        path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;mut T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt; { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait which allows nested <a href="trait.Reflect.html" title="trait bevy_reflect::Reflect"><code>Reflect</code></a> values to be retrieved with path strings.</p>
<p>Using these functions repeatedly with the same string requires parsing the string every time.
To avoid this cost, it’s recommended to construct a <a href="struct.ParsedPath.html" title="struct bevy_reflect::ParsedPath"><code>ParsedPath</code></a> instead.</p>
<h2 id="syntax"><a class="doc-anchor" href="#syntax">§</a>Syntax</h2><h3 id="structs"><a class="doc-anchor" href="#structs">§</a>Structs</h3>
<p>Field paths for <a href="trait.Struct.html" title="trait bevy_reflect::Struct"><code>Struct</code></a> elements use the standard Rust field access syntax of
dot and field name: <code>.field_name</code>.</p>
<p>Additionally, struct fields may be accessed by their index within the struct’s definition.
This is accomplished by using the hash symbol (<code>#</code>) in place of the standard dot: <code>#0</code>.</p>
<p>Accessing a struct’s field by index can speed up fetches at runtime due to the removed
need for string matching.
And while this can be more performant, it’s best to keep in mind the tradeoffs when
utilizing such optimizations.
For example, this can result in fairly fragile code as the string paths will need to be
kept in sync with the struct definitions since the order of fields could be easily changed.
Because of this, storing these kinds of paths in persistent storage (i.e. game assets)
is strongly discouraged.</p>
<p>Note that a leading dot (<code>.</code>) or hash (<code>#</code>) token is implied for the first item in a path,
and may therefore be omitted.</p>
<h4 id="example"><a class="doc-anchor" href="#example">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyStruct {
  value: u32
}

<span class="kw">let </span>my_struct = MyStruct { value: <span class="number">123 </span>};
<span class="comment">// Access via field name
</span><span class="macro">assert_eq!</span>(my_struct.path::&lt;u32&gt;(<span class="string">".value"</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);
<span class="comment">// Access via field index
</span><span class="macro">assert_eq!</span>(my_struct.path::&lt;u32&gt;(<span class="string">"#0"</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);</code></pre></div>
<h3 id="tuples-and-tuple-structs"><a class="doc-anchor" href="#tuples-and-tuple-structs">§</a>Tuples and Tuple Structs</h3>
<p><a href="trait.Tuple.html" title="trait bevy_reflect::Tuple"><code>Tuple</code></a> and <a href="trait.TupleStruct.html" title="trait bevy_reflect::TupleStruct"><code>TupleStruct</code></a> elements also follow a conventional Rust syntax.
Fields are accessed with a dot and the field index: <code>.0</code>.</p>
<p>Note that a leading dot (<code>.</code>) token is implied for the first item in a path,
and may therefore be omitted.</p>
<h4 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyTupleStruct(u32);

<span class="kw">let </span>my_tuple_struct = MyTupleStruct(<span class="number">123</span>);
<span class="macro">assert_eq!</span>(my_tuple_struct.path::&lt;u32&gt;(<span class="string">".0"</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);</code></pre></div>
<h3 id="lists-and-arrays"><a class="doc-anchor" href="#lists-and-arrays">§</a>Lists and Arrays</h3>
<p><a href="trait.List.html" title="trait bevy_reflect::List"><code>List</code></a> and <a href="trait.Array.html" title="trait bevy_reflect::Array"><code>Array</code></a> elements are accessed with brackets: <code>[0]</code>.</p>
<h4 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_list: Vec&lt;u32&gt; = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq!</span>(my_list.path::&lt;u32&gt;(<span class="string">"[2]"</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">3</span>);</code></pre></div>
<h3 id="enums"><a class="doc-anchor" href="#enums">§</a>Enums</h3>
<p>Pathing for <a href="trait.Enum.html" title="trait bevy_reflect::Enum"><code>Enum</code></a> elements works a bit differently than in normal Rust.
Usually, you would need to pattern match an enum, branching off on the desired variants.
Paths used by this trait do not have any pattern matching capabilities;
instead, they assume the variant is already known ahead of time.</p>
<p>The syntax used, therefore, depends on the variant being accessed:</p>
<ul>
<li>Struct variants use the struct syntax (outlined above)</li>
<li>Tuple variants use the tuple syntax (outlined above)</li>
<li>Unit variants have no fields to access</li>
</ul>
<p>If the variant cannot be known ahead of time, the path will need to be split up
and proper enum pattern matching will need to be handled manually.</p>
<h4 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">enum </span>MyEnum {
  Unit,
  Tuple(bool),
  Struct {
    value: u32
  }
}

<span class="kw">let </span>tuple_variant = MyEnum::Tuple(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(tuple_variant.path::&lt;bool&gt;(<span class="string">".0"</span>).unwrap(), <span class="kw-2">&amp;</span><span class="bool-val">true</span>);

<span class="kw">let </span>struct_variant = MyEnum::Struct { value: <span class="number">123 </span>};
<span class="comment">// Access via field name
</span><span class="macro">assert_eq!</span>(struct_variant.path::&lt;u32&gt;(<span class="string">".value"</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);
<span class="comment">// Access via field index
</span><span class="macro">assert_eq!</span>(struct_variant.path::&lt;u32&gt;(<span class="string">"#0"</span>).unwrap(), <span class="kw-2">&amp;</span><span class="number">123</span>);

<span class="comment">// Error: Expected struct variant
</span><span class="macro">assert!</span>(<span class="macro">matches!</span>(tuple_variant.path::&lt;u32&gt;(<span class="string">".value"</span>), <span class="prelude-val">Err</span>(<span class="kw">_</span>)));</code></pre></div>
<h2 id="chaining"><a class="doc-anchor" href="#chaining">§</a>Chaining</h2>
<p>Using the aforementioned syntax, path items may be chained one after another
to create a full path to a nested element.</p>
<h3 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Reflect)]
</span><span class="kw">struct </span>MyStruct {
  value: Vec&lt;<span class="prelude-ty">Option</span>&lt;u32&gt;&gt;
}

<span class="kw">let </span>my_struct = MyStruct {
  value: <span class="macro">vec!</span>[<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="number">123</span>)],
};
<span class="macro">assert_eq!</span>(
  my_struct.path::&lt;u32&gt;(<span class="string">".value[2].0"</span>).unwrap(),
  <span class="kw-2">&amp;</span><span class="number">123</span>,
);</code></pre></div>
</div></details><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.reflect_path" class="method"><a class="src rightside" href="../src/bevy_reflect/path/mod.rs.html#244-246">Source</a><h4 class="code-header">fn <a href="#method.reflect_path" class="fn">reflect_path</a>&lt;'p&gt;(
    &amp;self,
    path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;dyn <a class="trait" href="trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a reference to the value specified by <code>path</code>.</p>
<p>To retrieve a statically typed reference, use
<a href="trait.GetPath.html#method.path" title="method bevy_reflect::GetPath::path"><code>path</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reflect_path_mut" class="method"><a class="src rightside" href="../src/bevy_reflect/path/mod.rs.html#252-257">Source</a><h4 class="code-header">fn <a href="#method.reflect_path_mut" class="fn">reflect_path_mut</a>&lt;'p&gt;(
    &amp;mut self,
    path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;mut dyn <a class="trait" href="trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable reference to the value specified by <code>path</code>.</p>
<p>To retrieve a statically typed mutable reference, use
<a href="trait.GetPath.html#method.path_mut" title="method bevy_reflect::GetPath::path_mut"><code>path_mut</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.path" class="method"><a class="src rightside" href="../src/bevy_reflect/path/mod.rs.html#266-268">Source</a><h4 class="code-header">fn <a href="#method.path" class="fn">path</a>&lt;'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
    &amp;self,
    path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a statically typed reference to the value specified by <code>path</code>.</p>
<p>This will automatically handle downcasting to type <code>T</code>.
The downcast will fail if this value is not of type <code>T</code>
(which may be the case when using dynamic types like <a href="struct.DynamicStruct.html" title="struct bevy_reflect::DynamicStruct"><code>DynamicStruct</code></a>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.path_mut" class="method"><a class="src rightside" href="../src/bevy_reflect/path/mod.rs.html#277-279">Source</a><h4 class="code-header">fn <a href="#method.path_mut" class="fn">path_mut</a>&lt;'p, T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a>&gt;(
    &amp;mut self,
    path: impl <a class="trait" href="trait.ReflectPath.html" title="trait bevy_reflect::ReflectPath">ReflectPath</a>&lt;'p&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;mut T</a>, <a class="enum" href="enum.ReflectPathError.html" title="enum bevy_reflect::ReflectPathError">ReflectPathError</a>&lt;'p&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a statically typed mutable reference to the value specified by <code>path</code>.</p>
<p>This will automatically handle downcasting to type <code>T</code>.
The downcast will fail if this value is not of type <code>T</code>
(which may be the case when using dynamic types like <a href="struct.DynamicStruct.html" title="struct bevy_reflect::DynamicStruct"><code>DynamicStruct</code></a>).</p>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.85.0/reference/items/traits.html#object-safety">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-GetPath-for-T" class="impl"><a class="src rightside" href="../src/bevy_reflect/path/mod.rs.html#283">Source</a><a href="#impl-GetPath-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.Reflect.html" title="trait bevy_reflect::Reflect">Reflect</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="trait.GetPath.html" title="trait bevy_reflect::GetPath">GetPath</a> for T</h3></section></div><script src="../trait.impl/bevy_reflect/path/trait.GetPath.js" async></script></section></div></main></body></html>