<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Allows overriding the default deserialization behavior of `ReflectDeserializer` and `TypedReflectDeserializer` for specific `TypeRegistration`s."><title>ReflectDeserializerProcessor in bevy_reflect::serde - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bevy_reflect" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../bevy_reflect/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../bevy_reflect/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../bevy_reflect/index.html">bevy_<wbr>reflect</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Reflect<wbr>Deserializer<wbr>Processor</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#compared-to-deserializewithregistry" title="Compared to `DeserializeWithRegistry`">Compared to <code>DeserializeWithRegistry</code></a></li><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.try_deserialize" title="try_deserialize">try_deserialize</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-ReflectDeserializerProcessor-for-()" title="()">()</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In bevy_<wbr>reflect::<wbr>serde</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">bevy_reflect</a>::<wbr><a href="index.html">serde</a></span><h1>Trait <span class="trait">ReflectDeserializerProcessor</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bevy_reflect/serde/de/processor.rs.html#140-202">Source</a> </span></div><pre class="rust item-decl"><code>pub trait ReflectDeserializerProcessor {
    // Required method
    fn <a href="#tymethod.try_deserialize" class="fn">try_deserialize</a>&lt;'de, D&gt;(
        &amp;mut self,
        registration: &amp;<a class="struct" href="../struct.TypeRegistration.html" title="struct bevy_reflect::TypeRegistration">TypeRegistration</a>,
        registry: &amp;<a class="struct" href="../struct.TypeRegistry.html" title="struct bevy_reflect::TypeRegistry">TypeRegistry</a>,
        deserializer: D,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a>&gt;, D&gt;, D::<a class="associatedtype" href="../../serde/de/trait.Deserializer.html#associatedtype.Error" title="type serde::de::Deserializer::Error">Error</a>&gt;
       <span class="where">where D: <a class="trait" href="../../serde/de/trait.Deserializer.html" title="trait serde::de::Deserializer">Deserializer</a>&lt;'de&gt;</span>;
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Allows overriding the default deserialization behavior of
<a href="struct.ReflectDeserializer.html" title="struct bevy_reflect::serde::ReflectDeserializer"><code>ReflectDeserializer</code></a> and <a href="struct.TypedReflectDeserializer.html" title="struct bevy_reflect::serde::TypedReflectDeserializer"><code>TypedReflectDeserializer</code></a> for specific
<a href="../struct.TypeRegistration.html" title="struct bevy_reflect::TypeRegistration"><code>TypeRegistration</code></a>s.</p>
<p>When deserializing a reflected value, you may want to override the default
behavior and use your own logic for deserialization. This logic may also
be context-dependent, and only apply for a single use of your
<a href="struct.ReflectDeserializer.html" title="struct bevy_reflect::serde::ReflectDeserializer"><code>ReflectDeserializer</code></a>. To achieve this, you can create a processor and
pass it in to your deserializer.</p>
<p>Whenever the deserializer attempts to deserialize a value, it will first
call <a href="trait.ReflectDeserializerProcessor.html#tymethod.try_deserialize"><code>try_deserialize</code></a> on your processor, which may take ownership of the
deserializer and give back a <a href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box"><code>Box&lt;dyn PartialReflect&gt;</code></a>, or return
ownership of the deserializer back, and continue with the default logic.</p>
<p>The serialization equivalent of this is <a href="trait.ReflectSerializerProcessor.html" title="trait bevy_reflect::serde::ReflectSerializerProcessor"><code>ReflectSerializerProcessor</code></a>.</p>
<h2 id="compared-to-deserializewithregistry"><a class="doc-anchor" href="#compared-to-deserializewithregistry">§</a>Compared to <a href="trait.DeserializeWithRegistry.html" title="trait bevy_reflect::serde::DeserializeWithRegistry"><code>DeserializeWithRegistry</code></a></h2>
<p><a href="trait.DeserializeWithRegistry.html" title="trait bevy_reflect::serde::DeserializeWithRegistry"><code>DeserializeWithRegistry</code></a> allows you to define how your type will be
deserialized by a <a href="struct.TypedReflectDeserializer.html" title="struct bevy_reflect::serde::TypedReflectDeserializer"><code>TypedReflectDeserializer</code></a>, given the extra context of
the <a href="../struct.TypeRegistry.html" title="struct bevy_reflect::TypeRegistry"><code>TypeRegistry</code></a>. If your type can be deserialized entirely from that,
then you should prefer implementing that trait instead of using a processor.</p>
<p>However, you may need more context-dependent data which is only present in
the scope where you create the <a href="struct.TypedReflectDeserializer.html" title="struct bevy_reflect::serde::TypedReflectDeserializer"><code>TypedReflectDeserializer</code></a>. For example, in
an asset loader, the <code>&amp;mut LoadContext</code> you get is only valid from within
the <code>load</code> function. This is where a processor is useful, as the processor
can capture local variables.</p>
<p>A <a href="trait.ReflectDeserializerProcessor.html" title="trait bevy_reflect::serde::ReflectDeserializerProcessor"><code>ReflectDeserializerProcessor</code></a> always takes priority over a
<a href="trait.DeserializeWithRegistry.html" title="trait bevy_reflect::serde::DeserializeWithRegistry"><code>DeserializeWithRegistry</code></a> implementation, so this is also useful for
overriding deserialization behavior if you need to do something custom.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Deserializing a reflected value in an asset loader, and replacing asset
handles with a loaded equivalent:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Clone, Reflect)]
</span><span class="kw">struct </span>MyAsset {
    name: String,
    mesh: Handle&lt;Mesh&gt;,
}

<span class="kw">fn </span>load(
    asset_bytes: <span class="kw-2">&amp;</span>[u8],
    type_registry: <span class="kw-2">&amp;</span>TypeRegistry,
    load_context: <span class="kw-2">&amp;mut </span>LoadContext,
) -&gt; <span class="prelude-ty">Result</span>&lt;MyAsset, AssetError&gt; {
    <span class="kw">struct </span>HandleProcessor&lt;<span class="lifetime">'a</span>&gt; {
        load_context: <span class="kw-2">&amp;</span><span class="lifetime">'a </span><span class="kw-2">mut </span>LoadContext,
    }

    <span class="kw">impl </span>ReflectDeserializerProcessor <span class="kw">for </span>HandleProcessor&lt;<span class="lifetime">'_</span>&gt; {
        <span class="kw">fn </span>try_deserialize&lt;<span class="lifetime">'de</span>, D&gt;(
            <span class="kw-2">&amp;mut </span><span class="self">self</span>,
            registration: <span class="kw-2">&amp;</span>TypeRegistration,
            _registry: <span class="kw-2">&amp;</span>TypeRegistry,
            deserializer: D,
        ) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Result</span>&lt;Box&lt;<span class="kw">dyn </span>PartialReflect&gt;, D&gt;, D::Error&gt;
        <span class="kw">where
            </span>D: Deserializer&lt;<span class="lifetime">'de</span>&gt;,
        {
            <span class="kw">let </span><span class="prelude-val">Some</span>(reflect_handle) = registration.data::&lt;ReflectHandle&gt;() <span class="kw">else </span>{
                <span class="comment">// we don't want to deserialize this - give the deserializer back
                </span><span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="prelude-val">Err</span>(deserializer));
            };

            <span class="kw">let </span>asset_type_id = reflect_handle.asset_type_id();
            <span class="kw">let </span>asset_path = deserializer.deserialize_str(AssetPathVisitor)<span class="question-mark">?</span>;

            <span class="kw">let </span>handle: Handle&lt;LoadedUntypedAsset&gt; = <span class="self">self</span>.load_context
                .load()
                .with_asset_type_id(asset_type_id)
                .untyped()
                .load_asset(asset_path);
            <span class="prelude-val">Ok</span>(Box::new(handle))
        }
    }

    <span class="kw">let </span><span class="kw-2">mut </span>ron_deserializer = ron::Deserializer::from_bytes(asset_bytes)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>processor = HandleProcessor { load_context };
    <span class="kw">let </span>reflect_deserializer =
        ReflectDeserializer::with_processor(type_registry, <span class="kw-2">&amp;mut </span>processor);
    <span class="kw">let </span>asset = reflect_deserializer.deserialize(<span class="kw-2">&amp;mut </span>ron_deserializer)<span class="question-mark">?</span>;
}</code></pre></div>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.try_deserialize" class="method"><a class="src rightside" href="../../src/bevy_reflect/serde/de/processor.rs.html#194-201">Source</a><h4 class="code-header">fn <a href="#tymethod.try_deserialize" class="fn">try_deserialize</a>&lt;'de, D&gt;(
    &amp;mut self,
    registration: &amp;<a class="struct" href="../struct.TypeRegistration.html" title="struct bevy_reflect::TypeRegistration">TypeRegistration</a>,
    registry: &amp;<a class="struct" href="../struct.TypeRegistry.html" title="struct bevy_reflect::TypeRegistry">TypeRegistry</a>,
    deserializer: D,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a>&gt;, D&gt;, D::<a class="associatedtype" href="../../serde/de/trait.Deserializer.html#associatedtype.Error" title="type serde::de::Deserializer::Error">Error</a>&gt;<div class="where">where
    D: <a class="trait" href="../../serde/de/trait.Deserializer.html" title="trait serde::de::Deserializer">Deserializer</a>&lt;'de&gt;,</div></h4></section></summary><div class="docblock"><p>Attempts to deserialize the value which a <a href="struct.TypedReflectDeserializer.html" title="struct bevy_reflect::serde::TypedReflectDeserializer"><code>TypedReflectDeserializer</code></a>
is currently looking at, and knows the type of.</p>
<p>If you’ve read the <code>registration</code> and want to override the default
deserialization, return <code>Ok(Ok(value))</code> with the boxed reflected value
that you want to assign this value to. The type inside the box must
be the same one as the <code>registration</code> is for, otherwise future
reflection operations (such as using <a href="../trait.FromReflect.html" title="trait bevy_reflect::FromReflect"><code>FromReflect</code></a> to convert the
resulting <a href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box"><code>Box&lt;dyn PartialReflect&gt;</code></a> into a concrete type) will fail.</p>
<p>If you don’t want to override the deserialization, return ownership of
the deserializer back via <code>Ok(Err(deserializer))</code>.</p>
<p>Note that, if you do want to return a value, you <em>must</em> read from the
deserializer passed to this function (you are free to ignore the result
though). Otherwise, the deserializer will be in an inconsistent state,
and future value parsing will fail.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<p>Correct way to return a constant value (not using any output from the
deserializer):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>serde::de::IgnoredAny;

<span class="kw">struct </span>ConstantI32Processor;

<span class="kw">impl </span>ReflectDeserializerProcessor <span class="kw">for </span>ConstantI32Processor {
    <span class="kw">fn </span>try_deserialize&lt;<span class="lifetime">'de</span>, D&gt;(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        registration: <span class="kw-2">&amp;</span>TypeRegistration,
        _registry: <span class="kw-2">&amp;</span>TypeRegistry,
        deserializer: D,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Result</span>&lt;Box&lt;<span class="kw">dyn </span>PartialReflect&gt;, D&gt;, D::Error&gt;
    <span class="kw">where
        </span>D: serde::Deserializer&lt;<span class="lifetime">'de</span>&gt;
    {
        <span class="kw">if </span>registration.type_id() == TypeId::of::&lt;i32&gt;() {
            <span class="kw">_ </span>= deserializer.deserialize_ignored_any(IgnoredAny);
            <span class="prelude-val">Ok</span>(<span class="prelude-val">Ok</span>(Box::new(<span class="number">42_i32</span>)))
        } <span class="kw">else </span>{
            <span class="prelude-val">Ok</span>(<span class="prelude-val">Err</span>(deserializer))
        }
    }
}</code></pre></div>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.85.0/reference/items/traits.html#object-safety">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="foreign-impls" class="section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><details class="toggle implementors-toggle"><summary><section id="impl-ReflectDeserializerProcessor-for-()" class="impl"><a class="src rightside" href="../../src/bevy_reflect/serde/de/processor.rs.html#204-216">Source</a><a href="#impl-ReflectDeserializerProcessor-for-()" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.ReflectDeserializerProcessor.html" title="trait bevy_reflect::serde::ReflectDeserializerProcessor">ReflectDeserializerProcessor</a> for <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.unit.html">()</a></h3></section></summary><div class="impl-items"><section id="method.try_deserialize" class="method trait-impl"><a class="src rightside" href="../../src/bevy_reflect/serde/de/processor.rs.html#205-215">Source</a><a href="#method.try_deserialize" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.try_deserialize" class="fn">try_deserialize</a>&lt;'de, D&gt;(
    &amp;mut self,
    _registration: &amp;<a class="struct" href="../struct.TypeRegistration.html" title="struct bevy_reflect::TypeRegistration">TypeRegistration</a>,
    _registry: &amp;<a class="struct" href="../struct.TypeRegistry.html" title="struct bevy_reflect::TypeRegistry">TypeRegistry</a>,
    deserializer: D,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../trait.PartialReflect.html" title="trait bevy_reflect::PartialReflect">PartialReflect</a>&gt;, D&gt;, D::<a class="associatedtype" href="../../serde/de/trait.Deserializer.html#associatedtype.Error" title="type serde::de::Deserializer::Error">Error</a>&gt;<div class="where">where
    D: <a class="trait" href="../../serde/de/trait.Deserializer.html" title="trait serde::de::Deserializer">Deserializer</a>&lt;'de&gt;,</div></h4></section></div></details><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../trait.impl/bevy_reflect/serde/de/processor/trait.ReflectDeserializerProcessor.js" data-ignore-extern-crates="std" async></script></section></div></main></body></html>