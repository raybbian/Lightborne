<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="In Bevy, states are app-wide interdependent, finite state machines that are generally used to model the large scale structure of your program: whether a game is paused, if the player is in combat, if assets are loaded and so on."><title>bevy_state - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bevy_state" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bevy_state/index.html">bevy_<wbr>state</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>bevy_state</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bevy_state/lib.rs.html#1-79">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>In Bevy, states are app-wide interdependent, finite state machines that are generally used to model the large scale structure of your program: whether a game is paused, if the player is in combat, if assets are loaded and so on.</p>
<p>This module provides 3 distinct types of state, all of which implement the <a href="state/trait.States.html" title="trait bevy_state::state::States"><code>States</code></a> trait:</p>
<ul>
<li>Standard <a href="state/trait.States.html" title="trait bevy_state::state::States"><code>States</code></a> can only be changed by manually setting the <a href="state/enum.NextState.html" title="enum bevy_state::state::NextState"><code>NextState&lt;S&gt;</code></a> resource.
These states are the baseline on which the other state types are built, and can be used on
their own for many simple patterns. See the <a href="https://github.com/bevyengine/bevy/blob/latest/examples/state/state.rs">state example</a>
for a simple use case.</li>
<li><a href="state/trait.SubStates.html" title="trait bevy_state::state::SubStates"><code>SubStates</code></a> are children of other states - they can be changed manually using <a href="state/enum.NextState.html" title="enum bevy_state::state::NextState"><code>NextState&lt;S&gt;</code></a>,
but are removed from the <a href="../bevy_ecs/world/struct.World.html" title="struct bevy_ecs::world::World"><code>World</code></a> if the source states aren’t in the right state. See the <a href="https://github.com/bevyengine/bevy/blob/latest/examples/state/sub_states.rs">sub_states example</a>
for a simple use case based on the derive macro, or read the trait docs for more complex scenarios.</li>
<li><a href="state/trait.ComputedStates.html" title="trait bevy_state::state::ComputedStates"><code>ComputedStates</code></a> are fully derived from other states - they provide a <a href="state/trait.ComputedStates.html#tymethod.compute" title="associated function bevy_state::state::ComputedStates::compute"><code>compute</code></a> method
that takes in the source states and returns their derived value. They are particularly useful for situations
where a simplified view of the source states is necessary - such as having an <code>InAMenu</code> computed state, derived
from a source state that defines multiple distinct menus. See the <a href="https://github.com/bevyengine/bevy/blob/latest/examples/state/computed_states.rs">computed state example</a>
to see usage samples for these states.</li>
</ul>
<p>Most of the utilities around state involve running systems during transitions between states, or
determining whether to run certain systems, though they can be used more directly as well. This
makes it easier to transition between menus, add loading screens, pause games, and the more.</p>
<p>Specifically, Bevy provides the following utilities:</p>
<ul>
<li>3 Transition Schedules - <a href="state/struct.OnEnter.html" title="struct bevy_state::state::OnEnter"><code>OnEnter&lt;S&gt;</code></a>, <a href="state/struct.OnExit.html" title="struct bevy_state::state::OnExit"><code>OnExit&lt;S&gt;</code></a> and <a href="state/struct.OnTransition.html" title="struct bevy_state::state::OnTransition"><code>OnTransition&lt;S&gt;</code></a> - which are used
to trigger systems specifically during matching transitions.</li>
<li>A <a href="state/struct.StateTransitionEvent.html" title="struct bevy_state::state::StateTransitionEvent"><code>StateTransitionEvent&lt;S&gt;</code></a> that gets fired when a given state changes.</li>
<li>The <a href="condition/fn.in_state.html" title="fn bevy_state::condition::in_state"><code>in_state&lt;S&gt;</code></a> and <a href="condition/fn.state_changed.html" title="fn bevy_state::condition::state_changed"><code>state_changed&lt;S&gt;</code></a> run conditions - which are used
to determine whether a system should run based on the current state.</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="app/index.html" title="mod bevy_state::app">app</a></div><div class="desc docblock-short">Provides <a href="../bevy_app/app/struct.App.html" title="struct bevy_app::app::App"><code>App</code></a> and <a href="../bevy_app/sub_app/struct.SubApp.html" title="struct bevy_app::sub_app::SubApp"><code>SubApp</code></a> with state installation methods</div></li><li><div class="item-name"><a class="mod" href="commands/index.html" title="mod bevy_state::commands">commands</a></div><div class="desc docblock-short">Provides extension methods for <a href="../bevy_ecs/system/commands/struct.Commands.html" title="struct bevy_ecs::system::commands::Commands"><code>Commands</code></a>.</div></li><li><div class="item-name"><a class="mod" href="condition/index.html" title="mod bevy_state::condition">condition</a></div><div class="desc docblock-short">Provides definitions for the runtime conditions that interact with the state system</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod bevy_state::prelude">prelude</a></div><div class="desc docblock-short">The state prelude.</div></li><li><div class="item-name"><a class="mod" href="reflect/index.html" title="mod bevy_state::reflect">reflect</a></div><div class="desc docblock-short">Provides definitions for the basic traits required by the state system</div></li><li><div class="item-name"><a class="mod" href="state/index.html" title="mod bevy_state::state">state</a></div><div class="desc docblock-short">Provides definitions for the basic traits required by the state system</div></li><li><div class="item-name"><a class="mod" href="state_scoped/index.html" title="mod bevy_state::state_scoped">state_<wbr>scoped</a></div><div class="desc docblock-short">Provides <a href="state_scoped/struct.StateScoped.html" title="struct bevy_state::state_scoped::StateScoped"><code>StateScoped</code></a> and
<a href="state_scoped/fn.clear_state_scoped_entities.html" title="fn bevy_state::state_scoped::clear_state_scoped_entities"><code>clear_state_scoped_entities</code></a> for managing lifetime of entities.</div></li><li><div class="item-name"><a class="mod" href="state_scoped_events/index.html" title="mod bevy_state::state_scoped_events">state_<wbr>scoped_<wbr>events</a></div><div class="desc docblock-short">Provides <a href="../bevy_app/app/struct.App.html" title="struct bevy_app::app::App"><code>App</code></a> and <a href="../bevy_app/sub_app/struct.SubApp.html" title="struct bevy_app::sub_app::SubApp"><code>SubApp</code></a> with methods for registering
state-scoped events.</div></li></ul></section></div></main></body></html>