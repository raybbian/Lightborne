<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `Curve` trait, providing a domain-agnostic description of curves."><title>bevy_math::curve - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bevy_math" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../bevy_math/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../bevy_math/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../bevy_math/index.html">bevy_<wbr>math</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module curve</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#overview" title="Overview">Overview</a></li><li><a href="#analogy-with-iterator" title="Analogy with `Iterator`">Analogy with <code>Iterator</code></a></li><li><a href="#defining-curves" title="Defining curves">Defining curves</a></li><li><a href="#transforming-curves" title="Transforming curves">Transforming curves</a></li><li><a href="#combining-curves" title="Combining curves">Combining curves</a></li><li><a href="#resampling-and-rasterization" title="Resampling and rasterization">Resampling and rasterization</a></li><li><a href="#ownership-and-borrowing" title="Ownership and borrowing">Ownership and borrowing</a></li></ul><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate bevy_<wbr>math</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">bevy_math</a></span><h1>Module <span>curve</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bevy_math/curve/mod.rs.html#1-1319">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> trait, providing a domain-agnostic description of curves.</p>
<h3 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h3>
<p>At a high level, <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> is a trait that abstracts away the implementation details of curves,
which comprise any kind of data parametrized by a single continuous variable. For example, that
variable could represent time, in which case a curve would represent a value that changes over
time, as in animation; on the other hand, it could represent something like displacement or
distance, as in graphs, gradients, and curves in space.</p>
<p>The trait itself has two fundamental components: a curve must have a <a href="trait.Curve.html#tymethod.domain" title="method bevy_math::curve::Curve::domain">domain</a>, which is a nonempty
range of <code>f32</code> values, and it must be able to be <a href="trait.Curve.html#method.sample" title="method bevy_math::curve::Curve::sample">sampled</a> on every one of those values, producing
output of some fixed type.</p>
<p>A primary goal of the trait is to allow interfaces to simply accept <code>impl Curve&lt;T&gt;</code> as input
rather than requiring for input curves to be defined in data in any particular way. This is
supported by a number of interface methods which allow <a href="trait.Curve.html#method.reparametrize" title="method bevy_math::curve::Curve::reparametrize">changing parametrizations</a>, <a href="trait.Curve.html#method.map" title="method bevy_math::curve::Curve::map">mapping output</a>,
and <a href="trait.Curve.html#method.resample" title="method bevy_math::curve::Curve::resample">rasterization</a>.</p>
<h3 id="analogy-with-iterator"><a class="doc-anchor" href="#analogy-with-iterator">§</a>Analogy with <code>Iterator</code></h3>
<p>The <code>Curve</code> API behaves, in many ways, like a continuous counterpart to <a href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a>. The analogy
looks something like this with some of the common methods:</p>
<div><table><thead><tr><th style="text-align: left">Iterators</th><th style="text-align: left">Curves</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>map</code></td><td style="text-align: left"><code>map</code></td></tr>
<tr><td style="text-align: left"><code>skip</code>/<code>step_by</code></td><td style="text-align: left"><code>reparametrize</code></td></tr>
<tr><td style="text-align: left"><code>enumerate</code></td><td style="text-align: left"><code>graph</code></td></tr>
<tr><td style="text-align: left"><code>chain</code></td><td style="text-align: left"><code>chain</code></td></tr>
<tr><td style="text-align: left"><code>zip</code></td><td style="text-align: left"><code>zip</code></td></tr>
<tr><td style="text-align: left"><code>rev</code></td><td style="text-align: left"><code>reverse</code></td></tr>
<tr><td style="text-align: left"><code>by_ref</code></td><td style="text-align: left"><code>by_ref</code></td></tr>
</tbody></table>
</div>
<p>Of course, there are very important differences, as well. For instance, the continuous nature of
curves means that many iterator methods make little sense in the context of curves, or at least
require numerical techniques. For example, the analogue of <code>sum</code> would be an integral, approximated
by something like Riemann summation.</p>
<p>Furthermore, the two also differ greatly in their orientation to borrowing and mutation:
iterators are mutated by being iterated, and by contrast, all curve methods are immutable. More
information on the implications of this can be found <a href="index.html#Ownership-and-borrowing" title="mod bevy_math::curve">below</a>.</p>
<h3 id="defining-curves"><a class="doc-anchor" href="#defining-curves">§</a>Defining curves</h3>
<p>Curves may be defined in a number of ways. The following are common:</p>
<ul>
<li>using <a href="adaptors/struct.FunctionCurve.html" title="struct bevy_math::curve::adaptors::FunctionCurve">functions</a>;</li>
<li>using <a href="sample_curves/struct.SampleCurve.html" title="struct bevy_math::curve::sample_curves::SampleCurve">sample interpolation</a>;</li>
<li>using <a href="../cubic_splines/index.html" title="mod bevy_math::cubic_splines">splines</a>;</li>
<li>using <a href="easing/index.html" title="mod bevy_math::curve::easing">easings</a>.</li>
</ul>
<p>Among these, the first is the most versatile<sup id="fnref1"><a href="#fn1">1</a></sup>: the domain and the sampling output are just
specified directly in the construction. For this reason, function curves are a reliable go-to for
simple one-off constructions and procedural uses, where flexibility is desirable. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A sinusoid:
</span><span class="kw">let </span>sine_curve = FunctionCurve::new(Interval::EVERYWHERE, f32::sin);

<span class="comment">// A sawtooth wave:
</span><span class="kw">let </span>sawtooth_curve = FunctionCurve::new(Interval::EVERYWHERE, |t| t % <span class="number">1.0</span>);

<span class="comment">// A helix:
</span><span class="kw">let </span>helix_curve = FunctionCurve::new(Interval::EVERYWHERE, |theta| vec3(theta.sin(), theta, theta.cos()));</code></pre></div>
<p>Sample-interpolated curves commonly arises in both rasterization and in animation, and this library
has support for producing them in both fashions. See <a href="index.html#Resampling-and-rasterization" title="mod bevy_math::curve">below</a> for
more information about rasterization. Here is what an explicit sample-interpolated curve might look like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A list of angles that we want to traverse:
</span><span class="kw">let </span>angles = [
    <span class="number">0.0</span>,
    -FRAC_PI_2,
    <span class="number">0.0</span>,
    FRAC_PI_2,
    <span class="number">0.0
</span>];

<span class="comment">// Make each angle into a rotation by that angle:
</span><span class="kw">let </span>rotations = angles.map(|angle| Rot2::radians(angle));

<span class="comment">// Interpolate these rotations with a `Rot2`-valued curve:
</span><span class="kw">let </span>rotation_curve = SampleAutoCurve::new(interval(<span class="number">0.0</span>, <span class="number">4.0</span>).unwrap(), rotations).unwrap();</code></pre></div>
<p>For more information on <a href="../cubic_splines/index.html" title="mod bevy_math::cubic_splines">spline curves</a> and <a href="easing/index.html" title="mod bevy_math::curve::easing">easing curves</a>, see their respective modules.</p>
<p>And, of course, you are also free to define curve types yourself, implementing the trait directly.
For custom sample-interpolated curves, the <a href="cores/index.html" title="mod bevy_math::curve::cores"><code>cores</code></a> submodule provides machinery to avoid having to
reimplement interpolation logic yourself. In many other cases, implementing the trait directly is
often quite straightforward:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>ExponentialCurve {
    exponent: f32,
}

<span class="kw">impl </span>Curve&lt;f32&gt; <span class="kw">for </span>ExponentialCurve {
    <span class="kw">fn </span>domain(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Interval {
        Interval::EVERYWHERE
    }

    <span class="kw">fn </span>sample_unchecked(<span class="kw-2">&amp;</span><span class="self">self</span>, t: f32) -&gt; f32 {
        f32::exp(<span class="self">self</span>.exponent * t)
    }

    <span class="comment">// All other trait methods can be inferred from these.
</span>}</code></pre></div>
<h3 id="transforming-curves"><a class="doc-anchor" href="#transforming-curves">§</a>Transforming curves</h3>
<p>The API provides a few key ways of transforming one curve into another. These are often useful when
you would like to make use of an interface that requires a curve that bears some logical relationship
to one that you already have access to, but with different requirements or expectations. For example,
the output type of the curves may differ, or the domain may be expected to be different. The <code>map</code>
and <code>reparametrize</code> methods can help address this.</p>
<p>As a simple example of the kind of thing that arises in practice, let’s imagine that we have a
<code>Curve&lt;Vec2&gt;</code> that we want to use to describe the motion of some object over time, but the interface
for animation expects a <code>Curve&lt;Vec3&gt;</code>, since the object will move in three dimensions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Our original curve, which may look something like this:
</span><span class="kw">let </span>ellipse_curve = FunctionCurve::new(
    interval(<span class="number">0.0</span>, TAU).unwrap(),
    |t| vec2(t.cos(), t.sin() * <span class="number">2.0</span>)
);

<span class="comment">// Use `map` to situate this in 3D as a Curve&lt;Vec3&gt;; in this case, it will be in the xy-plane:
</span><span class="kw">let </span>ellipse_motion_curve = ellipse_curve.map(|pos| pos.extend(<span class="number">0.0</span>));</code></pre></div>
<p>We might imagine further still that the interface expects the curve to have domain <code>[0, 1]</code>. The
<code>reparametrize</code> methods can address this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Change the domain to `[0, 1]` instead of `[0, TAU]`:
</span><span class="kw">let </span>final_curve = ellipse_motion_curve.reparametrize_linear(Interval::UNIT).unwrap();</code></pre></div>
<p>Of course, there are many other ways of using these methods. In general, <code>map</code> is used for transforming
the output and using it to drive something else, while <code>reparametrize</code> preserves the curve’s shape but
changes the speed and direction in which it is traversed. For instance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A line segment curve connecting two points in the plane:
</span><span class="kw">let </span>start = vec2(-<span class="number">1.0</span>, <span class="number">1.0</span>);
<span class="kw">let </span>end = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>);
<span class="kw">let </span>segment = FunctionCurve::new(Interval::UNIT, |t| start.lerp(end, t));

<span class="comment">// Let's make a curve that goes back and forth along this line segment forever.
//
// Start by stretching the line segment in parameter space so that it travels along its length
// from `-1` to `1` instead of `0` to `1`:
</span><span class="kw">let </span>stretched_segment = segment.reparametrize_linear(interval(-<span class="number">1.0</span>, <span class="number">1.0</span>).unwrap()).unwrap();

<span class="comment">// Now, the *output* of `f32::sin` in `[-1, 1]` corresponds to the *input* interval of
// `stretched_segment`; the sinusoid output is mapped to the input parameter and controls how
// far along the segment we are:
</span><span class="kw">let </span>back_and_forth_curve = stretched_segment.reparametrize(Interval::EVERYWHERE, f32::sin);</code></pre></div>
<h3 id="combining-curves"><a class="doc-anchor" href="#combining-curves">§</a>Combining curves</h3>
<p>Curves become more expressive when used together. For example, maybe you want to combine two
curves end-to-end:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A line segment connecting `(-1, 0)` to `(0, 0)`:
</span><span class="kw">let </span>line_curve = FunctionCurve::new(
    Interval::UNIT,
    |t| vec2(-<span class="number">1.0</span>, <span class="number">0.0</span>).lerp(vec2(<span class="number">0.0</span>, <span class="number">0.0</span>), t)
);

<span class="comment">// A half-circle curve starting at `(0, 0)`:
</span><span class="kw">let </span>half_circle_curve = FunctionCurve::new(
    interval(<span class="number">0.0</span>, PI).unwrap(),
    |t| vec2(t.cos() * -<span class="number">1.0 </span>+ <span class="number">1.0</span>, t.sin())
);

<span class="comment">// A curve that traverses `line_curve` and then `half_circle_curve` over the interval
// from `0` to `PI + 1`:
</span><span class="kw">let </span>combined_curve = line_curve.chain(half_circle_curve).unwrap();</code></pre></div>
<p>Or, instead, maybe you want to combine two curves the <em>other</em> way, producing a single curve
that combines their output in a tuple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Some entity's position in 2D:
</span><span class="kw">let </span>position_curve = FunctionCurve::new(Interval::UNIT, |t| vec2(t.cos(), t.sin()));

<span class="comment">// The same entity's orientation, described as a rotation. (In this case it will be spinning.)
</span><span class="kw">let </span>orientation_curve = FunctionCurve::new(Interval::UNIT, |t| Rot2::radians(<span class="number">5.0 </span>* t));

<span class="comment">// Both in one curve with `(Vec2, Rot2)` output:
</span><span class="kw">let </span>position_and_orientation = position_curve.zip(orientation_curve).unwrap();</code></pre></div>
<p>See the documentation on <a href="trait.Curve.html#method.chain" title="method bevy_math::curve::Curve::chain"><code>chain</code></a> and <a href="trait.Curve.html#method.zip" title="method bevy_math::curve::Curve::zip"><code>zip</code></a> for more details on how these methods work.</p>
<h3 id="resampling-and-rasterization"><a class="doc-anchor" href="#resampling-and-rasterization">§</a><a name="Resampling-and-rasterization"></a>Resampling and rasterization</h3>
<p>Sometimes, for reasons of portability, performance, or otherwise, it can be useful to ensure that
curves of various provenance all actually share the same concrete type. This is the purpose of the
<a href="trait.Curve.html#method.resample" title="method bevy_math::curve::Curve::resample"><code>resample</code></a> family of functions: they allow a curve to be replaced by an approximate version of
itself defined by interpolation over samples from the original curve.</p>
<p>In effect, this allows very different curves to be rasterized and treated uniformly. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A curve that is not easily transported because it relies on evaluating a function:
</span><span class="kw">let </span>interesting_curve = FunctionCurve::new(Interval::UNIT, |t| vec2(t * <span class="number">3.0</span>, t.exp()));

<span class="comment">// A rasterized form of the preceding curve which is just a `SampleAutoCurve`. Inside, this
// just stores an `Interval` along with a buffer of sample data, so it's easy to serialize
// and deserialize:
</span><span class="kw">let </span>resampled_curve = interesting_curve.resample_auto(<span class="number">100</span>).unwrap();

<span class="comment">// The rasterized form can be seamlessly used as a curve itself:
</span><span class="kw">let </span>some_value = resampled_curve.sample(<span class="number">0.5</span>).unwrap();</code></pre></div>
<h3 id="ownership-and-borrowing"><a class="doc-anchor" href="#ownership-and-borrowing">§</a><a name="Ownership-and-borrowing"></a>Ownership and borrowing</h3>
<p>It can be easy to get tripped up by how curves specifically interact with Rust’s ownership semantics.
First of all, it’s worth noting that the API never uses <code>&amp;mut self</code> — every method either takes
ownership of the original curve or uses a shared reference.</p>
<p>Because of the methods that take ownership, it is useful to be aware of the following:</p>
<ul>
<li>If <code>curve</code> is a curve, then <code>&amp;curve</code> is also a curve with the same output. For convenience,
<code>&amp;curve</code> can be written as <code>curve.by_ref()</code> for use in method chaining.</li>
<li>However, <code>&amp;curve</code> cannot outlive <code>curve</code>. In general, it is not <code>'static</code>.</li>
</ul>
<p>In other words, <code>&amp;curve</code> can be used to perform temporary operations without consuming <code>curve</code> (for
example, to effectively pass <code>curve</code> into an API which expects an <code>impl Curve&lt;T&gt;</code>), but it <em>cannot</em>
be used in situations where persistence is necessary (e.g. when the curve itself must be stored
for later use).</p>
<p>Here is a demonstration:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//`my_curve` is obtained somehow. It is a `Curve&lt;(f32, f32)&gt;`.
</span><span class="kw">let </span>my_curve = some_magic_constructor();

<span class="comment">// Now, we want to sample a mapped version of `my_curve`.

// let samples: Vec&lt;f32&gt; = my_curve.map(|(x, y)| y).samples(50).unwrap().collect();
// ^ This would work, but it would also invalidate `my_curve`, since `map` takes ownership.

// Instead, we pass a borrowed version of `my_curve` to `map`. It lives long enough that we
// can extract samples:
</span><span class="kw">let </span>samples: Vec&lt;f32&gt; = my_curve.by_ref().map(|(x, y)| y).samples(<span class="number">50</span>).unwrap().collect();

<span class="comment">// This way, we retain the ability to use `my_curve` later:
</span><span class="kw">let </span>new_curve = my_curve.map(|(x,y)| x + y);</code></pre></div>
<div class="footnotes"><hr><ol><li id="fn1"><p>In fact, universal as well, in some sense: if <code>curve</code> is any curve, then <code>FunctionCurve::new (curve.domain(), |t| curve.sample_unchecked(t))</code> is an equivalent function curve.&nbsp;<a href="#fnref1">↩</a></p></li></ol></div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.interval"><code>pub use interval::<a class="fn" href="interval/fn.interval.html" title="fn bevy_math::curve::interval::interval">interval</a>;</code></div></li><li><div class="item-name" id="reexport.Interval"><code>pub use interval::<a class="struct" href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval">Interval</a>;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="adaptors/index.html" title="mod bevy_math::curve::adaptors">adaptors</a>::*;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="easing/index.html" title="mod bevy_math::curve::easing">easing</a>::*;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="sample_curves/index.html" title="mod bevy_math::curve::sample_curves">sample_curves</a>::*;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="adaptors/index.html" title="mod bevy_math::curve::adaptors">adaptors</a></div><div class="desc docblock-short">Adaptors used by the Curve API for transforming and combining curves together.</div></li><li><div class="item-name"><a class="mod" href="cores/index.html" title="mod bevy_math::curve::cores">cores</a></div><div class="desc docblock-short">Core data structures to be used internally in Curve implementations, encapsulating storage
and access patterns for reuse.</div></li><li><div class="item-name"><a class="mod" href="easing/index.html" title="mod bevy_math::curve::easing">easing</a></div><div class="desc docblock-short">Module containing different <a href="easing/enum.EaseFunction.html" title="enum bevy_math::curve::easing::EaseFunction">easing functions</a> to control the transition between two values and
the <a href="easing/struct.EasingCurve.html" title="struct bevy_math::curve::easing::EasingCurve"><code>EasingCurve</code></a> struct to make use of them.</div></li><li><div class="item-name"><a class="mod" href="interval/index.html" title="mod bevy_math::curve::interval">interval</a></div><div class="desc docblock-short">The <a href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval"><code>Interval</code></a> type for nonempty intervals used by the <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> trait.</div></li><li><div class="item-name"><a class="mod" href="iterable/index.html" title="mod bevy_math::curve::iterable">iterable</a></div><div class="desc docblock-short">Iterable curves, which sample in the form of an iterator in order to support <code>Vec</code>-like
output whose length cannot be known statically.</div></li><li><div class="item-name"><a class="mod" href="sample_curves/index.html" title="mod bevy_math::curve::sample_curves">sample_<wbr>curves</a></div><div class="desc docblock-short">Sample-interpolated curves constructed using the <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> API.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ChainError.html" title="enum bevy_math::curve::ChainError">Chain<wbr>Error</a></div><div class="desc docblock-short">An error indicating that an end-to-end composition couldn’t be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.LinearReparamError.html" title="enum bevy_math::curve::LinearReparamError">Linear<wbr>Reparam<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a linear reparametrization couldn’t be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.PingPongError.html" title="enum bevy_math::curve::PingPongError">Ping<wbr>Pong<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a ping ponging of a curve couldn’t be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.RepeatError.html" title="enum bevy_math::curve::RepeatError">Repeat<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a repetition of a curve couldn’t be performed because of malformed
inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">Resampling<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a resampling operation could not be performed because of
malformed inputs.</div></li><li><div class="item-name"><a class="enum" href="enum.ReverseError.html" title="enum bevy_math::curve::ReverseError">Reverse<wbr>Error</a></div><div class="desc docblock-short">An error indicating that a reversion of a curve couldn’t be performed because of
malformed inputs.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a></div><div class="desc docblock-short">A trait for a type that can represent values of type <code>T</code> parametrized over a fixed interval.</div></li></ul></section></div></main></body></html>