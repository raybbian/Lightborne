<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait for a type that can represent values of type `T` parametrized over a fixed interval."><title>Curve in bevy_math::curve - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="bevy_math" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://bevyengine.org/assets/icon.png"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../bevy_math/index.html"><img src="https://bevyengine.org/assets/icon.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../bevy_math/index.html"><img src="https://bevyengine.org/assets/icon.png" alt="logo"></a><h2><a href="../../bevy_math/index.html">bevy_<wbr>math</a><span class="version">0.15.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Curve</a></h2><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.domain" title="domain">domain</a></li><li><a href="#tymethod.sample_unchecked" title="sample_unchecked">sample_unchecked</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.by_ref" title="by_ref">by_ref</a></li><li><a href="#method.chain" title="chain">chain</a></li><li><a href="#method.chain_continue" title="chain_continue">chain_continue</a></li><li><a href="#method.flip" title="flip">flip</a></li><li><a href="#method.forever" title="forever">forever</a></li><li><a href="#method.graph" title="graph">graph</a></li><li><a href="#method.map" title="map">map</a></li><li><a href="#method.ping_pong" title="ping_pong">ping_pong</a></li><li><a href="#method.reparametrize" title="reparametrize">reparametrize</a></li><li><a href="#method.reparametrize_by_curve" title="reparametrize_by_curve">reparametrize_by_curve</a></li><li><a href="#method.reparametrize_linear" title="reparametrize_linear">reparametrize_linear</a></li><li><a href="#method.repeat" title="repeat">repeat</a></li><li><a href="#method.resample" title="resample">resample</a></li><li><a href="#method.resample_auto" title="resample_auto">resample_auto</a></li><li><a href="#method.resample_uneven" title="resample_uneven">resample_uneven</a></li><li><a href="#method.resample_uneven_auto" title="resample_uneven_auto">resample_uneven_auto</a></li><li><a href="#method.reverse" title="reverse">reverse</a></li><li><a href="#method.sample" title="sample">sample</a></li><li><a href="#method.sample_clamped" title="sample_clamped">sample_clamped</a></li><li><a href="#method.sample_iter" title="sample_iter">sample_iter</a></li><li><a href="#method.sample_iter_clamped" title="sample_iter_clamped">sample_iter_clamped</a></li><li><a href="#method.sample_iter_unchecked" title="sample_iter_unchecked">sample_iter_unchecked</a></li><li><a href="#method.samples" title="samples">samples</a></li><li><a href="#method.zip" title="zip">zip</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In bevy_<wbr>math::<wbr>curve</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">bevy_math</a>::<wbr><a href="index.html">curve</a></span><h1>Trait <span class="trait">Curve</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/bevy_math/curve/mod.rs.html#315-890">Source</a> </span></div><pre class="rust item-decl"><code>pub trait Curve&lt;T&gt; {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 26 methods</span></summary>    // Required methods
    fn <a href="#tymethod.domain" class="fn">domain</a>(&amp;self) -&gt; <a class="struct" href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval">Interval</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.sample_unchecked" class="fn">sample_unchecked</a>(&amp;self, t: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T;

    // Provided methods
    fn <a href="#method.sample" class="fn">sample</a>(&amp;self, t: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.sample_clamped" class="fn">sample_clamped</a>(&amp;self, t: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T { ... }
<span class="item-spacer"></span>    fn <a href="#method.sample_iter" class="fn">sample_iter</a>(
        &amp;self,
        iter: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
    ) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.sample_iter_unchecked" class="fn">sample_iter_unchecked</a>(
        &amp;self,
        iter: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
    ) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.sample_iter_clamped" class="fn">sample_iter_clamped</a>(
        &amp;self,
        iter: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
    ) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.map" class="fn">map</a>&lt;S, F&gt;(self, f: F) -&gt; <a class="struct" href="adaptors/struct.MapCurve.html" title="struct bevy_math::curve::adaptors::MapCurve">MapCurve</a>&lt;T, S, Self, F&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; S</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.reparametrize" class="fn">reparametrize</a>&lt;F&gt;(
        self,
        domain: <a class="struct" href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval">Interval</a>,
        f: F,
    ) -&gt; <a class="struct" href="adaptors/struct.ReparamCurve.html" title="struct bevy_math::curve::adaptors::ReparamCurve">ReparamCurve</a>&lt;T, Self, F&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.reparametrize_linear" class="fn">reparametrize_linear</a>(
        self,
        domain: <a class="struct" href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval">Interval</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.LinearReparamCurve.html" title="struct bevy_math::curve::adaptors::LinearReparamCurve">LinearReparamCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.LinearReparamError.html" title="enum bevy_math::curve::LinearReparamError">LinearReparamError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.reparametrize_by_curve" class="fn">reparametrize_by_curve</a>&lt;C&gt;(
        self,
        other: C,
    ) -&gt; <a class="struct" href="adaptors/struct.CurveReparamCurve.html" title="struct bevy_math::curve::adaptors::CurveReparamCurve">CurveReparamCurve</a>&lt;T, Self, C&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.graph" class="fn">graph</a>(self) -&gt; <a class="struct" href="adaptors/struct.GraphCurve.html" title="struct bevy_math::curve::adaptors::GraphCurve">GraphCurve</a>&lt;T, Self&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.zip" class="fn">zip</a>&lt;S, C&gt;(
        self,
        other: C,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ZipCurve.html" title="struct bevy_math::curve::adaptors::ZipCurve">ZipCurve</a>&lt;T, S, Self, C&gt;, <a class="struct" href="interval/struct.InvalidIntervalError.html" title="struct bevy_math::curve::interval::InvalidIntervalError">InvalidIntervalError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;S&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.chain" class="fn">chain</a>&lt;C&gt;(self, other: C) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ChainCurve.html" title="struct bevy_math::curve::adaptors::ChainCurve">ChainCurve</a>&lt;T, Self, C&gt;, <a class="enum" href="enum.ChainError.html" title="enum bevy_math::curve::ChainError">ChainError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.reverse" class="fn">reverse</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ReverseCurve.html" title="struct bevy_math::curve::adaptors::ReverseCurve">ReverseCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.ReverseError.html" title="enum bevy_math::curve::ReverseError">ReverseError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.repeat" class="fn">repeat</a>(self, count: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.RepeatCurve.html" title="struct bevy_math::curve::adaptors::RepeatCurve">RepeatCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.RepeatError.html" title="enum bevy_math::curve::RepeatError">RepeatError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.forever" class="fn">forever</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ForeverCurve.html" title="struct bevy_math::curve::adaptors::ForeverCurve">ForeverCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.RepeatError.html" title="enum bevy_math::curve::RepeatError">RepeatError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.ping_pong" class="fn">ping_pong</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.PingPongCurve.html" title="struct bevy_math::curve::adaptors::PingPongCurve">PingPongCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.PingPongError.html" title="enum bevy_math::curve::PingPongError">PingPongError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.chain_continue" class="fn">chain_continue</a>&lt;C&gt;(
        self,
        other: C,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ContinuationCurve.html" title="struct bevy_math::curve::adaptors::ContinuationCurve">ContinuationCurve</a>&lt;T, Self, C&gt;, <a class="enum" href="enum.ChainError.html" title="enum bevy_math::curve::ChainError">ChainError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             T: <a class="trait" href="../common_traits/trait.VectorSpace.html" title="trait bevy_math::common_traits::VectorSpace">VectorSpace</a>,
             C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.resample" class="fn">resample</a>&lt;I&gt;(
        &amp;self,
        segments: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>,
        interpolation: I,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.SampleCurve.html" title="struct bevy_math::curve::sample_curves::SampleCurve">SampleCurve</a>&lt;T, I&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             I: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.resample_auto" class="fn">resample_auto</a>(
        &amp;self,
        segments: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.SampleAutoCurve.html" title="struct bevy_math::curve::sample_curves::SampleAutoCurve">SampleAutoCurve</a>&lt;T&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             T: <a class="trait" href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">StableInterpolate</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.samples" class="fn">samples</a>(
        &amp;self,
        samples: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.resample_uneven" class="fn">resample_uneven</a>&lt;I&gt;(
        &amp;self,
        sample_times: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
        interpolation: I,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.UnevenSampleCurve.html" title="struct bevy_math::curve::sample_curves::UnevenSampleCurve">UnevenSampleCurve</a>&lt;T, I&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             I: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.resample_uneven_auto" class="fn">resample_uneven_auto</a>(
        &amp;self,
        sample_times: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.UnevenSampleAutoCurve.html" title="struct bevy_math::curve::sample_curves::UnevenSampleAutoCurve">UnevenSampleAutoCurve</a>&lt;T&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
             T: <a class="trait" href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">StableInterpolate</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.by_ref" class="fn">by_ref</a>(&amp;self) -&gt; &amp;Self
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a></span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.flip" class="fn">flip</a>&lt;U, V&gt;(self) -&gt; impl <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.tuple.html">(V, U)</a>&gt;
       <span class="where">where Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.tuple.html">(U, V)</a>&gt;</span> { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait for a type that can represent values of type <code>T</code> parametrized over a fixed interval.</p>
<p>Typical examples of this are actual geometric curves where <code>T: VectorSpace</code>, but other kinds
of output data can be represented as well. See the <a href="index.html" title="mod bevy_math::curve">module-level documentation</a> for details.</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.domain" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#319">Source</a><h4 class="code-header">fn <a href="#tymethod.domain" class="fn">domain</a>(&amp;self) -&gt; <a class="struct" href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval">Interval</a></h4></section></summary><div class="docblock"><p>The interval over which this curve is parametrized.</p>
<p>This is the range of values of <code>t</code> where we can sample the curve and receive valid output.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.sample_unchecked" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#328">Source</a><h4 class="code-header">fn <a href="#tymethod.sample_unchecked" class="fn">sample_unchecked</a>(&amp;self, t: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T</h4></section></summary><div class="docblock"><p>Sample a point on this curve at the parameter value <code>t</code>, extracting the associated value.
This is the unchecked version of sampling, which should only be used if the sample time <code>t</code>
is already known to lie within the curve’s domain.</p>
<p>Values sampled from outside of a curve’s domain are generally considered invalid; data which
is nonsensical or otherwise useless may be returned in such a circumstance, and extrapolation
beyond a curve’s domain should not be relied upon.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.sample" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#332-337">Source</a><h4 class="code-header">fn <a href="#method.sample" class="fn">sample</a>(&amp;self, t: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Sample a point on this curve at the parameter value <code>t</code>, returning <code>None</code> if the point is
outside of the curve’s domain.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_clamped" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#341-344">Source</a><h4 class="code-header">fn <a href="#method.sample_clamped" class="fn">sample_clamped</a>(&amp;self, t: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T</h4></section></summary><div class="docblock"><p>Sample a point on this curve at the parameter value <code>t</code>, clamping <code>t</code> to lie inside the
domain of the curve.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_iter" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#352-357">Source</a><h4 class="code-header">fn <a href="#method.sample_iter" class="fn">sample_iter</a>(
    &amp;self,
    iter: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Sample a collection of <code>n &gt;= 0</code> points on this curve at the parameter values <code>t_n</code>,
returning <code>None</code> if the point is outside of the curve’s domain.</p>
<p>The samples are returned in the same order as the parameter values <code>t_n</code> were provided and
will include all results. This leaves the responsibility for things like filtering and
sorting to the user for maximum flexibility.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_iter_unchecked" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#370-375">Source</a><h4 class="code-header">fn <a href="#method.sample_iter_unchecked" class="fn">sample_iter_unchecked</a>(
    &amp;self,
    iter: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Sample a collection of <code>n &gt;= 0</code> points on this curve at the parameter values <code>t_n</code>,
extracting the associated values. This is the unchecked version of sampling, which should
only be used if the sample times <code>t_n</code> are already known to lie within the curve’s domain.</p>
<p>Values sampled from outside of a curve’s domain are generally considered invalid; data
which is nonsensical or otherwise useless may be returned in such a circumstance, and
extrapolation beyond a curve’s domain should not be relied upon.</p>
<p>The samples are returned in the same order as the parameter values <code>t_n</code> were provided and
will include all results. This leaves the responsibility for things like filtering and
sorting to the user for maximum flexibility.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sample_iter_clamped" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#383-388">Source</a><h4 class="code-header">fn <a href="#method.sample_iter_clamped" class="fn">sample_iter_clamped</a>(
    &amp;self,
    iter: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Sample a collection of <code>n &gt;= 0</code> points on this curve at the parameter values <code>t_n</code>,
clamping <code>t_n</code> to lie inside the domain of the curve.</p>
<p>The samples are returned in the same order as the parameter values <code>t_n</code> were provided and
will include all results. This leaves the responsibility for things like filtering and
sorting to the user for maximum flexibility.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#394-404">Source</a><h4 class="code-header">fn <a href="#method.map" class="fn">map</a>&lt;S, F&gt;(self, f: F) -&gt; <a class="struct" href="adaptors/struct.MapCurve.html" title="struct bevy_math::curve::adaptors::MapCurve">MapCurve</a>&lt;T, S, Self, F&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(T) -&gt; S,</div></h4></section></summary><div class="docblock"><p>Create a new curve by mapping the values of this curve via a function <code>f</code>; i.e., if the
sample at time <code>t</code> for this curve is <code>x</code>, the value at time <code>t</code> on the new curve will be
<code>f(x)</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reparametrize" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#437-448">Source</a><h4 class="code-header">fn <a href="#method.reparametrize" class="fn">reparametrize</a>&lt;F&gt;(self, domain: <a class="struct" href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval">Interval</a>, f: F) -&gt; <a class="struct" href="adaptors/struct.ReparamCurve.html" title="struct bevy_math::curve::adaptors::ReparamCurve">ReparamCurve</a>&lt;T, Self, F&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> whose parameter space is related to the parameter space of this curve
by <code>f</code>. For each time <code>t</code>, the sample from the new curve at time <code>t</code> is the sample from
this curve at time <code>f(t)</code>. The given <code>domain</code> will be the domain of the new curve. The
function <code>f</code> is expected to take <code>domain</code> into <code>self.domain()</code>.</p>
<p>Note that this is the opposite of what one might expect intuitively; for example, if this
curve has a parameter domain of <code>[0, 1]</code>, then stretching the parameter domain to
<code>[0, 2]</code> would be performed as follows, dividing by what might be perceived as the scaling
factor rather than multiplying:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_curve = ConstantCurve::new(Interval::UNIT, <span class="number">1.0</span>);
<span class="kw">let </span>scaled_curve = my_curve.reparametrize(interval(<span class="number">0.0</span>, <span class="number">2.0</span>).unwrap(), |t| t / <span class="number">2.0</span>);</code></pre></div>
<p>This kind of linear remapping is provided by the convenience method
<a href="trait.Curve.html#method.reparametrize_linear" title="method bevy_math::curve::Curve::reparametrize_linear"><code>Curve::reparametrize_linear</code></a>, which requires only the desired domain for the new curve.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Reverse a curve:
</span><span class="kw">let </span>my_curve = ConstantCurve::new(Interval::UNIT, <span class="number">1.0</span>);
<span class="kw">let </span>domain = my_curve.domain();
<span class="kw">let </span>reversed_curve = my_curve.reparametrize(domain, |t| domain.end() - (t - domain.start()));

<span class="comment">// Take a segment of a curve:
</span><span class="kw">let </span>curve_segment = my_curve.reparametrize(interval(<span class="number">0.0</span>, <span class="number">0.5</span>).unwrap(), |t| <span class="number">0.5 </span>+ t);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reparametrize_linear" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#454-474">Source</a><h4 class="code-header">fn <a href="#method.reparametrize_linear" class="fn">reparametrize_linear</a>(
    self,
    domain: <a class="struct" href="interval/struct.Interval.html" title="struct bevy_math::curve::interval::Interval">Interval</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.LinearReparamCurve.html" title="struct bevy_math::curve::adaptors::LinearReparamCurve">LinearReparamCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.LinearReparamError.html" title="enum bevy_math::curve::LinearReparamError">LinearReparamError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Linearly reparametrize this <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a>, producing a new curve whose domain is the given
<code>domain</code> instead of the current one. This operation is only valid for curves with bounded
domains; if either this curve’s domain or the given <code>domain</code> is unbounded, an error is
returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reparametrize_by_curve" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#482-492">Source</a><h4 class="code-header">fn <a href="#method.reparametrize_by_curve" class="fn">reparametrize_by_curve</a>&lt;C&gt;(self, other: C) -&gt; <a class="struct" href="adaptors/struct.CurveReparamCurve.html" title="struct bevy_math::curve::adaptors::CurveReparamCurve">CurveReparamCurve</a>&lt;T, Self, C&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Reparametrize this <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> by sampling from another curve.</p>
<p>The resulting curve samples at time <code>t</code> by first sampling <code>other</code> at time <code>t</code>, which produces
another sample time <code>s</code> which is then used to sample this curve. The domain of the resulting
curve is the domain of <code>other</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.graph" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#501-509">Source</a><h4 class="code-header">fn <a href="#method.graph" class="fn">graph</a>(self) -&gt; <a class="struct" href="adaptors/struct.GraphCurve.html" title="struct bevy_math::curve::adaptors::GraphCurve">GraphCurve</a>&lt;T, Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> which is the graph of this one; that is, its output echoes the sample
time as part of a tuple.</p>
<p>For example, if this curve outputs <code>x</code> at time <code>t</code>, then the produced curve will produce
<code>(t, x)</code> at time <code>t</code>. In particular, if this curve is a <code>Curve&lt;T&gt;</code>, the output of this method
is a <code>Curve&lt;(f32, T)&gt;</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zip" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#517-529">Source</a><h4 class="code-header">fn <a href="#method.zip" class="fn">zip</a>&lt;S, C&gt;(
    self,
    other: C,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ZipCurve.html" title="struct bevy_math::curve::adaptors::ZipCurve">ZipCurve</a>&lt;T, S, Self, C&gt;, <a class="struct" href="interval/struct.InvalidIntervalError.html" title="struct bevy_math::curve::interval::InvalidIntervalError">InvalidIntervalError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;S&gt; + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> by zipping this curve together with another.</p>
<p>The sample at time <code>t</code> in the new curve is <code>(x, y)</code>, where <code>x</code> is the sample of <code>self</code> at
time <code>t</code> and <code>y</code> is the sample of <code>other</code> at time <code>t</code>. The domain of the new curve is the
intersection of the domains of its constituents. If the domain intersection would be empty,
an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chain" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#539-555">Source</a><h4 class="code-header">fn <a href="#method.chain" class="fn">chain</a>&lt;C&gt;(self, other: C) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ChainCurve.html" title="struct bevy_math::curve::adaptors::ChainCurve">ChainCurve</a>&lt;T, Self, C&gt;, <a class="enum" href="enum.ChainError.html" title="enum bevy_math::curve::ChainError">ChainError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> by composing this curve end-to-start with another, producing another curve
with outputs of the same type. The domain of the other curve is translated so that its start
coincides with where this curve ends.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>A <a href="enum.ChainError.html" title="enum bevy_math::curve::ChainError"><code>ChainError</code></a> is returned if this curve’s domain doesn’t have a finite end or if
<code>other</code>’s domain doesn’t have a finite start.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#565-576">Source</a><h4 class="code-header">fn <a href="#method.reverse" class="fn">reverse</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ReverseCurve.html" title="struct bevy_math::curve::adaptors::ReverseCurve">ReverseCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.ReverseError.html" title="enum bevy_math::curve::ReverseError">ReverseError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> inverting this curve on the x-axis, producing another curve with
outputs of the same type, effectively playing backwards starting at <code>self.domain().end()</code>
and transitioning over to <code>self.domain().start()</code>. The domain of the new curve is still the
same.</p>
<h5 id="error"><a class="doc-anchor" href="#error">§</a>Error</h5>
<p>A <a href="enum.ReverseError.html" title="enum bevy_math::curve::ReverseError"><code>ReverseError</code></a> is returned if this curve’s domain isn’t bounded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#592-613">Source</a><h4 class="code-header">fn <a href="#method.repeat" class="fn">repeat</a>(self, count: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.RepeatCurve.html" title="struct bevy_math::curve::adaptors::RepeatCurve">RepeatCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.RepeatError.html" title="enum bevy_math::curve::RepeatError">RepeatError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> repeating this curve <code>N</code> times, producing another curve with outputs
of the same type. The domain of the new curve will be bigger by a factor of <code>n + 1</code>.</p>
<h5 id="notes"><a class="doc-anchor" href="#notes">§</a>Notes</h5>
<ul>
<li>this doesn’t guarantee a smooth transition from one occurrence of the curve to its next
iteration. The curve will make a jump if <code>self.domain().start() != self.domain().end()</code>!</li>
<li>for <code>count == 0</code> the output of this adaptor is basically identical to the previous curve</li>
<li>the value at the transitioning points (<code>domain.end() * n</code> for <code>n &gt;= 1</code>) in the results is the
value at <code>domain.end()</code> in the original curve</li>
</ul>
<h5 id="error-1"><a class="doc-anchor" href="#error-1">§</a>Error</h5>
<p>A <a href="enum.RepeatError.html" title="enum bevy_math::curve::RepeatError"><code>RepeatError</code></a> is returned if this curve’s domain isn’t bounded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.forever" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#628-639">Source</a><h4 class="code-header">fn <a href="#method.forever" class="fn">forever</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ForeverCurve.html" title="struct bevy_math::curve::adaptors::ForeverCurve">ForeverCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.RepeatError.html" title="enum bevy_math::curve::RepeatError">RepeatError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> repeating this curve forever, producing another curve with
outputs of the same type. The domain of the new curve will be unbounded.</p>
<h5 id="notes-1"><a class="doc-anchor" href="#notes-1">§</a>Notes</h5>
<ul>
<li>this doesn’t guarantee a smooth transition from one occurrence of the curve to its next
iteration. The curve will make a jump if <code>self.domain().start() != self.domain().end()</code>!</li>
<li>the value at the transitioning points (<code>domain.end() * n</code> for <code>n &gt;= 1</code>) in the results is the
value at <code>domain.end()</code> in the original curve</li>
</ul>
<h5 id="error-2"><a class="doc-anchor" href="#error-2">§</a>Error</h5>
<p>A <a href="enum.RepeatError.html" title="enum bevy_math::curve::RepeatError"><code>RepeatError</code></a> is returned if this curve’s domain isn’t bounded.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ping_pong" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#648-659">Source</a><h4 class="code-header">fn <a href="#method.ping_pong" class="fn">ping_pong</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.PingPongCurve.html" title="struct bevy_math::curve::adaptors::PingPongCurve">PingPongCurve</a>&lt;T, Self&gt;, <a class="enum" href="enum.PingPongError.html" title="enum bevy_math::curve::PingPongError">PingPongError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> chaining the original curve with its inverse, producing
another curve with outputs of the same type. The domain of the new curve will be twice as
long. The transition point is guaranteed to not make any jumps.</p>
<h5 id="error-3"><a class="doc-anchor" href="#error-3">§</a>Error</h5>
<p>A <a href="enum.PingPongError.html" title="enum bevy_math::curve::PingPongError"><code>PingPongError</code></a> is returned if this curve’s domain isn’t right-finite.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chain_continue" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#676-698">Source</a><h4 class="code-header">fn <a href="#method.chain_continue" class="fn">chain_continue</a>&lt;C&gt;(
    self,
    other: C,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="adaptors/struct.ContinuationCurve.html" title="struct bevy_math::curve::adaptors::ContinuationCurve">ContinuationCurve</a>&lt;T, Self, C&gt;, <a class="enum" href="enum.ChainError.html" title="enum bevy_math::curve::ChainError">ChainError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    T: <a class="trait" href="../common_traits/trait.VectorSpace.html" title="trait bevy_math::common_traits::VectorSpace">VectorSpace</a>,
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h4></section></summary><div class="docblock"><p>Create a new <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> by composing this curve end-to-start with another, producing another
curve with outputs of the same type. The domain of the other curve is translated so that
its start coincides with where this curve ends.</p>
<p>Additionally the transition of the samples is guaranteed to make no sudden jumps. This is
useful if you really just know about the shapes of your curves and don’t want to deal with
stitching them together properly when it would just introduce useless complexity. It is
realized by translating the other curve so that its start sample point coincides with the
current curves’ end sample point.</p>
<h5 id="error-4"><a class="doc-anchor" href="#error-4">§</a>Error</h5>
<p>A <a href="enum.ChainError.html" title="enum bevy_math::curve::ChainError"><code>ChainError</code></a> is returned if this curve’s domain doesn’t have a finite end or if
<code>other</code>’s domain doesn’t have a finite start.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resample" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#719-736">Source</a><h4 class="code-header">fn <a href="#method.resample" class="fn">resample</a>&lt;I&gt;(
    &amp;self,
    segments: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>,
    interpolation: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.SampleCurve.html" title="struct bevy_math::curve::sample_curves::SampleCurve">SampleCurve</a>&lt;T, I&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T,</div></h4></section></summary><div class="docblock"><p>Resample this <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> to produce a new one that is defined by interpolation over equally
spaced sample values, using the provided <code>interpolation</code> to interpolate between adjacent samples.
The curve is interpolated on <code>segments</code> segments between samples. For example, if <code>segments</code> is 1,
only the start and end points of the curve are used as samples; if <code>segments</code> is 2, a sample at
the midpoint is taken as well, and so on. If <code>segments</code> is zero, or if this curve has an unbounded
domain, then a <a href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError"><code>ResamplingError</code></a> is returned.</p>
<p>The interpolation takes two values by reference together with a scalar parameter and
produces an owned value. The expectation is that <code>interpolation(&amp;x, &amp;y, 0.0)</code> and
<code>interpolation(&amp;x, &amp;y, 1.0)</code> are equivalent to <code>x</code> and <code>y</code> respectively.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>quarter_rotation = FunctionCurve::new(interval(<span class="number">0.0</span>, <span class="number">90.0</span>).unwrap(), |t| Rot2::degrees(t));
<span class="comment">// A curve which only stores three data points and uses `nlerp` to interpolate them:
</span><span class="kw">let </span>resampled_rotation = quarter_rotation.resample(<span class="number">3</span>, |x, y, t| x.nlerp(<span class="kw-2">*</span>y, t));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resample_auto" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#746-758">Source</a><h4 class="code-header">fn <a href="#method.resample_auto" class="fn">resample_auto</a>(
    &amp;self,
    segments: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.SampleAutoCurve.html" title="struct bevy_math::curve::sample_curves::SampleAutoCurve">SampleAutoCurve</a>&lt;T&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    T: <a class="trait" href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">StableInterpolate</a>,</div></h4></section></summary><div class="docblock"><p>Resample this <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> to produce a new one that is defined by interpolation over equally
spaced sample values, using <a href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">automatic interpolation</a> to interpolate between adjacent samples.
The curve is interpolated on <code>segments</code> segments between samples. For example, if <code>segments</code> is 1,
only the start and end points of the curve are used as samples; if <code>segments</code> is 2, a sample at
the midpoint is taken as well, and so on. If <code>segments</code> is zero, or if this curve has an unbounded
domain, then a <a href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError"><code>ResamplingError</code></a> is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.samples" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#762-780">Source</a><h4 class="code-header">fn <a href="#method.samples" class="fn">samples</a>(
    &amp;self,
    samples: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Extract an iterator over evenly-spaced samples from this curve. If <code>samples</code> is less than 2
or if this curve has unbounded domain, then an error is returned instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resample_uneven" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#797-821">Source</a><h4 class="code-header">fn <a href="#method.resample_uneven" class="fn">resample_uneven</a>&lt;I&gt;(
    &amp;self,
    sample_times: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
    interpolation: I,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.UnevenSampleCurve.html" title="struct bevy_math::curve::sample_curves::UnevenSampleCurve">UnevenSampleCurve</a>&lt;T, I&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T,</div></h4></section></summary><div class="docblock"><p>Resample this <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> to produce a new one that is defined by interpolation over samples
taken at a given set of times. The given <code>interpolation</code> is used to interpolate adjacent
samples, and the <code>sample_times</code> are expected to contain at least two valid times within the
curve’s domain interval.</p>
<p>Redundant sample times, non-finite sample times, and sample times outside of the domain
are simply filtered out. With an insufficient quantity of data, a <a href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError"><code>ResamplingError</code></a> is
returned.</p>
<p>The domain of the produced curve stretches between the first and last sample times of the
iterator.</p>
<p>The interpolation takes two values by reference together with a scalar parameter and
produces an owned value. The expectation is that <code>interpolation(&amp;x, &amp;y, 0.0)</code> and
<code>interpolation(&amp;x, &amp;y, 1.0)</code> are equivalent to <code>x</code> and <code>y</code> respectively.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resample_uneven_auto" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#835-857">Source</a><h4 class="code-header">fn <a href="#method.resample_uneven_auto" class="fn">resample_uneven_auto</a>(
    &amp;self,
    sample_times: impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="sample_curves/struct.UnevenSampleAutoCurve.html" title="struct bevy_math::curve::sample_curves::UnevenSampleAutoCurve">UnevenSampleAutoCurve</a>&lt;T&gt;, <a class="enum" href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError">ResamplingError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    T: <a class="trait" href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">StableInterpolate</a>,</div></h4></section></summary><div class="docblock"><p>Resample this <a href="trait.Curve.html" title="trait bevy_math::curve::Curve"><code>Curve</code></a> to produce a new one that is defined by <a href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">automatic interpolation</a> over
samples taken at the given set of times. The given <code>sample_times</code> are expected to contain at least
two valid times within the curve’s domain interval.</p>
<p>Redundant sample times, non-finite sample times, and sample times outside of the domain
are simply filtered out. With an insufficient quantity of data, a <a href="enum.ResamplingError.html" title="enum bevy_math::curve::ResamplingError"><code>ResamplingError</code></a> is
returned.</p>
<p>The domain of the produced <a href="sample_curves/struct.UnevenSampleAutoCurve.html" title="struct bevy_math::curve::sample_curves::UnevenSampleAutoCurve"><code>UnevenSampleAutoCurve</code></a> stretches between the first and last
sample times of the iterator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.by_ref" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#875-880">Source</a><h4 class="code-header">fn <a href="#method.by_ref" class="fn">by_ref</a>(&amp;self) -&gt; &amp;Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Borrow this curve rather than taking ownership of it. This is essentially an alias for a
prefix <code>&amp;</code>; the point is that intermediate operations can be performed while retaining
access to the original curve.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_curve = FunctionCurve::new(Interval::UNIT, |t| t * t + <span class="number">1.0</span>);

<span class="comment">// Borrow `my_curve` long enough to resample a mapped version. Note that `map` takes
// ownership of its input.
</span><span class="kw">let </span>samples = my_curve.by_ref().map(|x| x * <span class="number">2.0</span>).resample_auto(<span class="number">100</span>).unwrap();

<span class="comment">// Do something else with `my_curve` since we retained ownership:
</span><span class="kw">let </span>new_curve = my_curve.reparametrize_linear(interval(-<span class="number">1.0</span>, <span class="number">1.0</span>).unwrap()).unwrap();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flip" class="method"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#884-889">Source</a><h4 class="code-header">fn <a href="#method.flip" class="fn">flip</a>&lt;U, V&gt;(self) -&gt; impl <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.tuple.html">(V, U)</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.tuple.html">(U, V)</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Flip this curve so that its tuple output is arranged the other way.</p>
</div></details></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-Curve%3CP%3E-for-CubicCurve%3CP%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/cubic_splines.rs.html#1203-1215">Source</a><a href="#impl-Curve%3CP%3E-for-CubicCurve%3CP%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../common_traits/trait.VectorSpace.html" title="trait bevy_math::common_traits::VectorSpace">VectorSpace</a>&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;P&gt; for <a class="struct" href="../cubic_splines/struct.CubicCurve.html" title="struct bevy_math::cubic_splines::CubicCurve">CubicCurve</a>&lt;P&gt;</h3></section><section id="impl-Curve%3CP%3E-for-CubicSegment%3CP%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/cubic_splines.rs.html#1065-1075">Source</a><a href="#impl-Curve%3CP%3E-for-CubicSegment%3CP%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../common_traits/trait.VectorSpace.html" title="trait bevy_math::common_traits::VectorSpace">VectorSpace</a>&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;P&gt; for <a class="struct" href="../cubic_splines/struct.CubicSegment.html" title="struct bevy_math::cubic_splines::CubicSegment">CubicSegment</a>&lt;P&gt;</h3></section><section id="impl-Curve%3CP%3E-for-RationalCurve%3CP%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/cubic_splines.rs.html#1532-1544">Source</a><a href="#impl-Curve%3CP%3E-for-RationalCurve%3CP%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../common_traits/trait.VectorSpace.html" title="trait bevy_math::common_traits::VectorSpace">VectorSpace</a>&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;P&gt; for <a class="struct" href="../cubic_splines/struct.RationalCurve.html" title="struct bevy_math::cubic_splines::RationalCurve">RationalCurve</a>&lt;P&gt;</h3></section><section id="impl-Curve%3CP%3E-for-RationalSegment%3CP%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/cubic_splines.rs.html#1375-1385">Source</a><a href="#impl-Curve%3CP%3E-for-RationalSegment%3CP%3E" class="anchor">§</a><h3 class="code-header">impl&lt;P: <a class="trait" href="../common_traits/trait.VectorSpace.html" title="trait bevy_math::common_traits::VectorSpace">VectorSpace</a>&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;P&gt; for <a class="struct" href="../cubic_splines/struct.RationalSegment.html" title="struct bevy_math::cubic_splines::RationalSegment">RationalSegment</a>&lt;P&gt;</h3></section><section id="impl-Curve%3C(S,+T)%3E-for-ZipCurve%3CS,+T,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#480-497">Source</a><a href="#impl-Curve%3C(S,+T)%3E-for-ZipCurve%3CS,+T,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;S, T, C, D&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.tuple.html">(S, T)</a>&gt; for <a class="struct" href="adaptors/struct.ZipCurve.html" title="struct bevy_math::curve::adaptors::ZipCurve">ZipCurve</a>&lt;S, T, C, D&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;S&gt;,
    D: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-MapCurve%3CS,+T,+C,+F%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#254-268">Source</a><a href="#impl-Curve%3CT%3E-for-MapCurve%3CS,+T,+C,+F%3E" class="anchor">§</a><h3 class="code-header">impl&lt;S, T, C, F&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.MapCurve.html" title="struct bevy_math::curve::adaptors::MapCurve">MapCurve</a>&lt;S, T, C, F&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;S&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(S) -&gt; T,</div></h3></section><section id="impl-Curve%3CT%3E-for-ConstantCurve%3CT%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#56-69">Source</a><a href="#impl-Curve%3CT%3E-for-ConstantCurve%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.ConstantCurve.html" title="struct bevy_math::curve::adaptors::ConstantCurve">ConstantCurve</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section><section id="impl-Curve%3CT%3E-for-EasingCurve%3CT%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/easing.rs.html#110-125">Source</a><a href="#impl-Curve%3CT%3E-for-EasingCurve%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="easing/struct.EasingCurve.html" title="struct bevy_math::curve::easing::EasingCurve">EasingCurve</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="easing/trait.Ease.html" title="trait bevy_math::curve::easing::Ease">Ease</a> + <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section><section id="impl-Curve%3CT%3E-for-SampleAutoCurve%3CT%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/sample_curves.rs.html#142-162">Source</a><a href="#impl-Curve%3CT%3E-for-SampleAutoCurve%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="sample_curves/struct.SampleAutoCurve.html" title="struct bevy_math::curve::sample_curves::SampleAutoCurve">SampleAutoCurve</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">StableInterpolate</a>,</div></h3></section><section id="impl-Curve%3CT%3E-for-UnevenSampleAutoCurve%3CT%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/sample_curves.rs.html#312-332">Source</a><a href="#impl-Curve%3CT%3E-for-UnevenSampleAutoCurve%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="sample_curves/struct.UnevenSampleAutoCurve.html" title="struct bevy_math::curve::sample_curves::UnevenSampleAutoCurve">UnevenSampleAutoCurve</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../common_traits/trait.StableInterpolate.html" title="trait bevy_math::common_traits::StableInterpolate">StableInterpolate</a>,</div></h3></section><section id="impl-Curve%3C(f32,+T)%3E-for-GraphCurve%3CT,+C%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#448-461">Source</a><a href="#impl-Curve%3C(f32,+T)%3E-for-GraphCurve%3CT,+C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>, T)&gt; for <a class="struct" href="adaptors/struct.GraphCurve.html" title="struct bevy_math::curve::adaptors::GraphCurve">GraphCurve</a>&lt;T, C&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-ForeverCurve%3CT,+C%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#659-680">Source</a><a href="#impl-Curve%3CT%3E-for-ForeverCurve%3CT,+C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.ForeverCurve.html" title="struct bevy_math::curve::adaptors::ForeverCurve">ForeverCurve</a>&lt;T, C&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-LinearReparamCurve%3CT,+C%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#383-398">Source</a><a href="#impl-Curve%3CT%3E-for-LinearReparamCurve%3CT,+C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.LinearReparamCurve.html" title="struct bevy_math::curve::adaptors::LinearReparamCurve">LinearReparamCurve</a>&lt;T, C&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-PingPongCurve%3CT,+C%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#703-728">Source</a><a href="#impl-Curve%3CT%3E-for-PingPongCurve%3CT,+C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.PingPongCurve.html" title="struct bevy_math::curve::adaptors::PingPongCurve">PingPongCurve</a>&lt;T, C&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-RepeatCurve%3CT,+C%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#611-632">Source</a><a href="#impl-Curve%3CT%3E-for-RepeatCurve%3CT,+C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.RepeatCurve.html" title="struct bevy_math::curve::adaptors::RepeatCurve">RepeatCurve</a>&lt;T, C&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-ReverseCurve%3CT,+C%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#569-583">Source</a><a href="#impl-Curve%3CT%3E-for-ReverseCurve%3CT,+C%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.ReverseCurve.html" title="struct bevy_math::curve::adaptors::ReverseCurve">ReverseCurve</a>&lt;T, C&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-ChainCurve%3CT,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#520-547">Source</a><a href="#impl-Curve%3CT%3E-for-ChainCurve%3CT,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C, D&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.ChainCurve.html" title="struct bevy_math::curve::adaptors::ChainCurve">ChainCurve</a>&lt;T, C, D&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,
    D: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-ContinuationCurve%3CT,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#760-788">Source</a><a href="#impl-Curve%3CT%3E-for-ContinuationCurve%3CT,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C, D&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.ContinuationCurve.html" title="struct bevy_math::curve::adaptors::ContinuationCurve">ContinuationCurve</a>&lt;T, C, D&gt;<div class="where">where
    T: <a class="trait" href="../common_traits/trait.VectorSpace.html" title="trait bevy_math::common_traits::VectorSpace">VectorSpace</a>,
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,
    D: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-CurveReparamCurve%3CT,+C,+D%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#416-431">Source</a><a href="#impl-Curve%3CT%3E-for-CurveReparamCurve%3CT,+C,+D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C, D&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.CurveReparamCurve.html" title="struct bevy_math::curve::adaptors::CurveReparamCurve">CurveReparamCurve</a>&lt;T, C, D&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,
    D: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-D" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/mod.rs.html#892-904">Source</a><a href="#impl-Curve%3CT%3E-for-D" class="anchor">§</a><h3 class="code-header">impl&lt;T, C, D&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for D<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    D: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = C&gt;,</div></h3></section><section id="impl-Curve%3CT%3E-for-ReparamCurve%3CT,+C,+F%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#349-363">Source</a><a href="#impl-Curve%3CT%3E-for-ReparamCurve%3CT,+C,+F%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, C, F&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.ReparamCurve.html" title="struct bevy_math::curve::adaptors::ReparamCurve">ReparamCurve</a>&lt;T, C, F&gt;<div class="where">where
    C: <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>,</div></h3></section><section id="impl-Curve%3CT%3E-for-FunctionCurve%3CT,+F%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/adaptors.rs.html#159-172">Source</a><a href="#impl-Curve%3CT%3E-for-FunctionCurve%3CT,+F%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, F&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="adaptors/struct.FunctionCurve.html" title="struct bevy_math::curve::adaptors::FunctionCurve">FunctionCurve</a>&lt;T, F&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T,</div></h3></section><section id="impl-Curve%3CT%3E-for-SampleCurve%3CT,+I%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/sample_curves.rs.html#86-106">Source</a><a href="#impl-Curve%3CT%3E-for-SampleCurve%3CT,+I%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, I&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="sample_curves/struct.SampleCurve.html" title="struct bevy_math::curve::sample_curves::SampleCurve">SampleCurve</a>&lt;T, I&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T,</div></h3></section><section id="impl-Curve%3CT%3E-for-UnevenSampleCurve%3CT,+I%3E" class="impl"><a class="src rightside" href="../../src/bevy_math/curve/sample_curves.rs.html#246-266">Source</a><a href="#impl-Curve%3CT%3E-for-UnevenSampleCurve%3CT,+I%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, I&gt; <a class="trait" href="trait.Curve.html" title="trait bevy_math::curve::Curve">Curve</a>&lt;T&gt; for <a class="struct" href="sample_curves/struct.UnevenSampleCurve.html" title="struct bevy_math::curve::sample_curves::UnevenSampleCurve">UnevenSampleCurve</a>&lt;T, I&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.f32.html">f32</a>) -&gt; T,</div></h3></section></div><script src="../../trait.impl/bevy_math/curve/trait.Curve.js" async></script></section></div></main></body></html>